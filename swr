#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"CLI/Osprey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLI_OSPREY';
  package CLI::Osprey;use strict;use warnings;our$VERSION='0.03';our$AUTHORITY='cpan:ARODLAND';use Carp 'croak';use Module::Runtime 'use_module';use Scalar::Util qw(reftype);use CLI::Osprey::InlineSubcommand ();my@OPTIONS_ATTRIBUTES=qw(option option_name format short repeatable negatable spacer_before spacer_after doc long_doc format_doc order hidden);sub import {my (undef,@import_options)=@_;my$target=caller;for my$method (qw(with around has)){next if$target->can($method);croak "Can't find the method '$method' in package '$target'. CLI::Osprey requires a Role::Tiny-compatible object system like Moo or Moose."}my$with=$target->can('with');my$around=$target->can('around');my$has=$target->can('has');my@target_isa=do {no strict 'refs';@{"${target}::ISA"}};if (@target_isa){eval "package $target;\n" .q{
        sub _osprey_options {
          my $class = shift;
          return $class->maybe::next::method(@_);
        }
  
        sub _osprey_config {
          my $class = shift;
          return $class->maybe::next::method(@_);
        }
  
        sub _osprey_subcommands {
          my $class = shift;
          return $class->maybe::next::method(@_);
        }
        1;
      } || croak($@)}my$osprey_config={preserve_argv=>1,abbreviate=>1,prefer_commandline=>1,@import_options,};$around->(_osprey_config=>sub {my ($orig,$self)=(shift,shift);return$self->$orig(@_),%$osprey_config});my$options_data={};my$subcommands={};my$apply_modifiers=sub {return if$target->can('new_with_options');$with->('CLI::Osprey::Role');$around->(_osprey_options=>sub {my ($orig,$self)=(shift,shift);return$self->$orig(@_),%$options_data});$around->(_osprey_subcommands=>sub {my ($orig,$self)=(shift,shift);return$self->$orig(@_),%$subcommands})};my$added_order=0;my$option=sub {my ($name,%attributes)=@_;$has->($name=>_non_option_attributes(%attributes));$options_data->{$name}=_option_attributes($name,added_order=>++$added_order,%attributes);$apply_modifiers->()};my$subcommand=sub {my ($name,$subobject)=@_;if (ref($subobject)&& reftype($subobject)eq 'CODE'){my@args=@_[2 .. $#_];$subobject=CLI::Osprey::InlineSubcommand->new(name=>$name,method=>$subobject,@args,)}else {use_module($subobject)}$subcommands->{$name}=$subobject;$apply_modifiers->()};if (my$info=$Role::Tiny::INFO{$target}){$info->{not_methods}{$option}=$option;$info->{not_methods}{$subcommand}=$subcommand}{no strict 'refs';*{"${target}::option"}=$option;*{"${target}::subcommand"}=$subcommand}$apply_modifiers->();return}sub _non_option_attributes {my (%attributes)=@_;my%filter_out;@filter_out{@OPTIONS_ATTRIBUTES}=();return map {$_=>$attributes{$_}}grep {!exists$filter_out{$_}}keys%attributes}sub _option_attributes {my ($name,%attributes)=@_;unless (defined$attributes{option}){($attributes{option}=$name)=~ tr/_/-/}my$ret={};for (@OPTIONS_ATTRIBUTES){$ret->{$_}=$attributes{$_}if exists$attributes{$_}}return$ret}1;
CLI_OSPREY

$fatpacked{"CLI/Osprey/Descriptive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLI_OSPREY_DESCRIPTIVE';
  package CLI::Osprey::Descriptive;use strict;use warnings;our$VERSION='0.03';our$AUTHORITY='cpan:ARODLAND';use Getopt::Long::Descriptive 0.100;use CLI::Osprey::Descriptive::Usage;our@ISA=('Getopt::Long::Descriptive');sub usage_class {'CLI::Osprey::Descriptive::Usage'}1;
CLI_OSPREY_DESCRIPTIVE

$fatpacked{"CLI/Osprey/Descriptive/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLI_OSPREY_DESCRIPTIVE_USAGE';
  package CLI::Osprey::Descriptive::Usage;use strict;use warnings;use Moo;use overload (q{""}=>"text",);use Getopt::Long::Descriptive::Usage ();our$VERSION='0.03';our$AUTHORITY='cpan:ARODLAND';my%format_doc=(s=>{short=>"string",long=>"string" },i=>{short=>"int",long=>"integer" },o=>{short=>"int",long=>"integer (dec/hex/bin/oct)" },f=>{short=>"num",long=>"number" },);has 'options'=>(is=>'ro',);has 'leader_text'=>(is=>'ro',);has 'target'=>(is=>'ro',predicate=>1,);has 'prog_name'=>(is=>'ro',predicate=>1,);has 'width'=>(is=>'ro',default=>sub {return$ENV{CLI_OSPREY_OVERRIDE_WIDTH}if exists$ENV{CLI_OSPREY_OVERRIDE_WIDTH};return$ENV{COLUMNS}if exists$ENV{COLUMNS};return 80},);sub wrap {my ($self,$in,$prefix)=@_;my$width=$self->width;return$in if$width <= 0;my@out;my$line="";while ($in =~ /(\s*)(\S+)/g){my ($space,$nonspace)=($1,$2);if (length($line)+ length($space)+ length($nonspace)<= $width){$line .= $space .$nonspace}else {while (length($nonspace)){push@out,$line;$line=$prefix;$line .= substr($nonspace,0,$width - length($line),'')}}}push@out,$line if length($line);return@out}sub maxlen {my$max=0;for (@_){$max=length($_)if length($_)> $max}return$max}sub sub_commands_text {my ($self,$length)=@_;if ($self->has_target && (my%subcommands=$self->target->_osprey_subcommands)){if ($length eq 'long'){my$maxlen=maxlen(keys%subcommands);my@out;push@out,"";push@out,"Subcommands available:";for my$name (sort keys%subcommands){my$desc=$subcommands{$name}->can('_osprey_subcommand_desc')&& $subcommands{$name}->_osprey_subcommand_desc;if (defined$desc){push@out,$self->wrap(sprintf("%*s  %s",-$maxlen,$name,$subcommands{$name}->_osprey_subcommand_desc)," " x ($maxlen + 2))}else {push@out,$name}}push@out,"";return@out}else {return "",$self->wrap("Subcommands available: " .join(" | ",sort keys%subcommands)," " x length("Subcommands available: "))}}return}sub pod_escape {my ($self,$text)=@_;my%map=('<'=>'lt','>'=>'gt','|'=>'verbar','/'=>'sol',);$text =~ s,([<>|/]),"E<$map{$1}>",eg;return$text}sub describe_opt {my ($self,$opt)=@_;if ($opt->{desc}eq 'spacer'){return {spacer=>1 }}my$name=my$attr_name=$opt->{name};my$option_attrs;if ($self->has_target){my%options=$self->target->_osprey_options;$option_attrs=$options{$attr_name};$name=$option_attrs->{option}if defined$option_attrs->{option}}my ($short,$format)=$opt->{spec}=~ /(?:\|(\w))?(?:=(.*?))?$/;my$array;if (defined$format && $format =~ s/[\@\+]$//){$array=1}my$format_doc;if (defined$format){if (defined$option_attrs->{format_doc}){$format_doc={short=>$option_attrs->{format_doc},long=>$option_attrs->{format_doc},}}else {$format_doc=$format_doc{$format}}}my$spec;if ($short){$spec="-$short|"}if (length($name)> 1){$spec .= "--$name"}else {$spec .= "-$name"}my ($shortspec,$longspec)=($spec,$spec);my ($podshortspec,$podlongspec)=("B<< $spec >>","B<< $spec >>");if (defined$format_doc){$shortspec .= " $format_doc->{short}";$podshortspec .= " I<< $format_doc->{short} >>";$longspec .= " $format_doc->{long}";$podlongspec .= " I<< $format_doc->{long} >>"}if ($array){$shortspec .= "...";$podshortspec .= "..."}if (defined$option_attrs &&!$option_attrs->{required}){$shortspec="[$shortspec]";$podshortspec="[$podshortspec]"}return {short=>$shortspec,long=>$longspec,podshort=>$podshortspec,podlong=>$podlongspec,doc=>$opt->{desc},long_doc=>defined($option_attrs->{long_doc})? $option_attrs->{long_doc}: $self->pod_escape($opt->{desc}),}}sub describe_options {my ($self)=@_;return map$self->describe_opt($_),@{$self->options}}sub header {my ($self)=@_;my@descs=$self->describe_options;my$option_text=join "\n",$self->wrap(join(" ",map $_->{short},grep!$_->{spacer},@descs),"  ",);my$text=$self->leader_text;$text =~ s/\Q[long options...]/$option_text/;return$text}sub text {my ($self)=@_;return join "\n",$self->header,$self->sub_commands_text('short')}sub option_help {my ($self)=@_;my@descs=$self->describe_options;my$maxlen=maxlen(map $_->{long},grep!$_->{spacer},@descs);my@out;for my$desc (@descs){if ($desc->{spacer}){push@out,""}else {push@out,$self->wrap(sprintf("%*s  %s",-$maxlen,$desc->{long},$desc->{doc})," " x ($maxlen + 2),)}}return join("\n",$self->header,$self->sub_commands_text('long'),@out)}sub option_pod {my ($self)=@_;my%osprey_config=$self->target->_osprey_options;my@descs=$self->describe_options;my@pod;push@pod,"=encoding UTF-8";push@pod,"=head1 NAME";push@pod,$self->{prog_name}.($osprey_config{desc}? " - " .$osprey_config{desc}: "");push@pod,"=head1 SYNOPSIS";push@pod,"B<< $self->{prog_name} >> " .join(" ",map "S<<< $_->{podshort} >>>",grep!$_->{spacer},@descs);if ($osprey_config{description_pod}){push@pod,"=head1 DESCRIPTION";push@pod,$osprey_config{description_pod}}if ($osprey_config{extra_pod}){push@pod,$osprey_config{extra_pod}}push@pod,"=head1 OPTIONS";push@pod,"=over";for my$desc (@descs){if ($desc->{spacer}){push@pod,"=back";push@pod,"E<32>" x 40;push@pod,"=over"}else {push@pod,"=item $desc->{podlong}";push@pod,$desc->{long_doc}}}push@pod,"=back";if ($self->has_target && (my%subcommands=$self->target->_osprey_subcommands)){push@pod,"=head1 COMMANDS";push@pod,"=over";for my$name (sort keys%subcommands){my$desc=$subcommands{$name}->can('_osprey_subcommand_desc')&& $subcommands{$name}->_osprey_subcommand_desc;push@pod,"=item B<< $name >>";if ($desc){push@pod,$desc}}push@pod,"=back"}return join("\n\n",@pod)}1;
CLI_OSPREY_DESCRIPTIVE_USAGE

$fatpacked{"CLI/Osprey/InlineSubcommand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLI_OSPREY_INLINESUBCOMMAND';
  package CLI::Osprey::InlineSubcommand;use strict;use warnings;use Moo;our$VERSION='0.03';our$AUTHORITY='cpan:ARODLAND';has 'name'=>(is=>'ro',required=>1,);has 'desc'=>(is=>'bare',reader=>'_osprey_subcommand_desc',);has 'method'=>(is=>'ro',required=>1,);has 'parent_command'=>(is=>'rw',);has 'argv'=>(is=>'rw',);sub new_with_options {my ($self,%args)=@_;$self->parent_command($args{parent_command });$self->argv([@ARGV ]);return$self}sub run {my ($self)=@_;my$cmd=$self->parent_command;my$method=$self->method;@_=($self->parent_command,@{$self->argv});goto &$method}no Moo;1;
CLI_OSPREY_INLINESUBCOMMAND

$fatpacked{"CLI/Osprey/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLI_OSPREY_ROLE';
  package CLI::Osprey::Role;use strict;use warnings;use Carp 'croak';use Path::Tiny ();use Scalar::Util qw(blessed);use CLI::Osprey::Descriptive;our$VERSION='0.03';our$AUTHORITY='cpan:ARODLAND';sub _osprey_option_to_getopt {my ($name,%attributes)=@_;my$getopt=join('|',grep defined,($name,$attributes{short}));$getopt .= '+' if$attributes{repeatable}&&!defined$attributes{format};$getopt .= '!' if$attributes{negatable};$getopt .= '=' .$attributes{format}if defined$attributes{format};$getopt .= '@' if$attributes{repeatable}&& defined$attributes{format};return$getopt}sub _osprey_prepare_options {my ($options,$config)=@_;my@getopt;my%abbreviations;my%fullnames;my@order=sort {($options->{$a}{order}|| 9999)<=> ($options->{$b}{order}|| 9999)|| ($config->{added_order}? ($options->{$a}{added_order}<=> $options->{$b}{added_order}): 0)|| $a cmp $b}keys %$options;for my$option (@order){my%attributes=%{$options->{$option}};push @{$fullnames{$attributes{option}}},$option}for my$name (keys%fullnames){if (@{$fullnames{$name}}> 1){croak "Multiple option attributes named $name: [@{ $fullnames{$name} }]"}}for my$option (@order){my%attributes=%{$options->{$option}};my$name=$attributes{option};my$doc=$attributes{doc};$doc="no documentation for $name" unless defined$doc;push@getopt,[]if$attributes{spacer_before};push@getopt,[_osprey_option_to_getopt($option,%attributes),$doc,($attributes{hidden}? {hidden=>1}: ())];push@getopt,[]if$attributes{spacer_after};push @{$abbreviations{$name}},$option;if ($config->{abbreviate}){for my$len (1 .. length($name)- 1){my$abbreviated=substr$name,0,$len;push @{$abbreviations{$abbreviated}},$name unless exists$fullnames{$abbreviated}}}}return \@getopt,\%abbreviations}sub _osprey_fix_argv {my ($options,$abbreviations)=@_;my@new_argv;while (defined(my$arg=shift@ARGV)){if ($arg eq '--' or $arg !~ /^-/){push@new_argv,$arg,@ARGV;last}my ($arg_name_with_dash,$arg_value)=split /=/,$arg,2;unshift@ARGV,$arg_value if defined$arg_value;my ($dash,$negative,$arg_name_without_dash)=$arg_name_with_dash =~ /^(-+)(no\-)?(.+)$/;my$option_name=$abbreviations->{$arg_name_without_dash};if (defined$option_name){if (@$option_name==1){$option_name=$option_name->[0]}else {$option_name=undef}}my$arg_name=($dash || '').($negative || '');if (defined$option_name){$arg_name .= $option_name}else {$arg_name .= $arg_name_without_dash}push@new_argv,$arg_name;if (defined$option_name && $options->{$option_name}{format}){push@new_argv,shift@ARGV}}return@new_argv}use Moo::Role;requires qw(_osprey_config _osprey_options _osprey_subcommands);has 'parent_command'=>(is=>'ro',);has 'invoked_as'=>(is=>'ro',);sub new_with_options {my ($class,%params)=@_;my%config=$class->_osprey_config;local@ARGV=@ARGV if$config{protect_argv};if (!defined$params{invoked_as}){$params{invoked_as}=Getopt::Long::Descriptive::prog_name()}my ($parsed_params,$usage)=$class->parse_options(%params);if ($parsed_params->{h}){return$class->osprey_usage(1,$usage)}elsif ($parsed_params->{help}){return$class->osprey_help(1,$usage)}elsif ($parsed_params->{man}){return$class->osprey_man($usage)}my%merged_params;if ($config{prefer_commandline}){%merged_params=(%$parsed_params,%params)}else {%merged_params=(%params,%$parsed_params)}my%subcommands=$class->_osprey_subcommands;my ($subcommand_name,$subcommand_class);if (@ARGV && $ARGV[0]ne '--'){if ($ARGV[0]=~ /^--/){print STDERR "Unknown option '$ARGV[0]'.\n";return$class->osprey_usage(1,$usage)}elsif (%subcommands){$subcommand_name=shift@ARGV;$subcommand_class=$subcommands{$subcommand_name};if (!defined$subcommand_class){print STDERR "Unknown subcommand '$subcommand_name'.\n";return$class->osprey_usage(1,$usage)}}}my$self;unless (eval {$self=$class->new(%merged_params);1}){if ($@ =~ /^Attribute \((.*?)\) is required/){print STDERR "$1 is missing\n"}elsif ($@ =~ /^Missing required arguments: (.*) at /){my@missing_required=split /,\s/,$1;print STDERR "$_ is missing\n" for@missing_required}elsif ($@ =~ /^(.*?) required/){print STDERR "$1 is missing\n"}elsif ($@ =~ /^isa check .*?failed: /){print STDERR substr($@,index($@,':')+ 2)}else {print STDERR $@}return$class->osprey_usage(1,$usage)}if ($subcommand_class){return$subcommand_class->new_with_options(%params,parent_command=>$self,invoked_as=>"$params{invoked_as} $subcommand_name")}else {return$self}}sub parse_options {my ($class,%params)=@_;my%options=$class->_osprey_options;my%config=$class->_osprey_config;my%subcommands=$class->_osprey_subcommands;my ($options,$abbreviations)=_osprey_prepare_options(\%options,\%config);@ARGV=_osprey_fix_argv(\%options,$abbreviations);my@getopt_options=%subcommands ? qw(require_order) : ();push@getopt_options,@{$config{getopt_options}}if defined$config{getopt_options};my$prog_name=$params{invoked_as};$prog_name=Getopt::Long::Descriptive::prog_name()if!defined$prog_name;my$usage_str=$config{usage_string};unless (defined$usage_str){if (%subcommands){$usage_str="Usage: $prog_name %o [subcommand]"}else {$usage_str="Usage: $prog_name %o"}}my ($opt,$usage)=describe_options($usage_str,@$options,[],['h',"show a short help message" ],['help',"show a long help message" ],['man',"show the manual" ],{getopt_conf=>\@getopt_options },);$usage->{prog_name}=$prog_name;$usage->{target}=$class;if ($usage->{should_die}){return$class->osprey_usage(1,$usage)}my%parsed_params;for my$name (keys%options,qw(h help man)){my$val=$opt->$name();$parsed_params{$name}=$val if defined$val}return \%parsed_params,$usage}sub osprey_usage {my ($class,$code,@messages)=@_;my$usage;if (@messages && blessed($messages[0])&& $messages[0]->isa('CLI::Osprey::Descriptive::Usage')){$usage=shift@messages}else {local@ARGV=();(undef,$usage)=$class->parse_options(help=>1)}my$message;$message=join("\n",@messages,'')if@messages;$message .= $usage ."\n";if ($code){CORE::warn$message}else {print$message}exit$code if defined$code;return}sub osprey_help {my ($class,$code,$usage)=@_;unless (defined$usage && blessed($usage)&& $usage->isa('CLI::Osprey::Descriptive::Usage')){local@ARGV=();(undef,$usage)=$class->parse_options(help=>1)}my$message=$usage->option_help ."\n";if ($code){CORE::warn$message}else {print$message}exit$code if defined$code;return}sub osprey_man {my ($class,$usage,$output)=@_;unless (defined$usage && blessed($usage)&& $usage->isa('CLI::Osprey::Descriptive::Usage')){local@ARGV=();(undef,$usage)=$class->parse_options(man=>1)}my$tmpdir=Path::Tiny->tempdir;my$podfile=$tmpdir->child("help.pod");$podfile->spew_utf8($usage->option_pod);require Pod::Usage;Pod::Usage::pod2usage(-verbose=>2,-input=>"$podfile",-exitval=>'NOEXIT',-output=>$output,);exit(0)}sub _osprey_subcommand_desc {my ($class)=@_;my%config=$class->_osprey_config;return$config{desc}}1;
CLI_OSPREY_ROLE

$fatpacked{"Class/Method/Modifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_METHOD_MODIFIERS';
  use strict;use warnings;package Class::Method::Modifiers;our$VERSION='2.12';use base 'Exporter';our@EXPORT=qw(before after around);our@EXPORT_OK=(@EXPORT,qw(fresh install_modifier));our%EXPORT_TAGS=(moose=>[qw(before after around)],all=>\@EXPORT_OK,);BEGIN {*_HAS_READONLY=$] >= 5.008 ? sub(){1}: sub(){0}}our%MODIFIER_CACHE;sub _install_modifier;*_install_modifier=\&install_modifier;sub install_modifier {my$into=shift;my$type=shift;my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';return _fresh($into,$code,@names)if$type eq 'fresh';for my$name (@names){my$hit=$into->can($name)or do {require Carp;Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into")};my$qualified=$into.'::'.$name;my$cache=$MODIFIER_CACHE{$into}{$name}||= {before=>[],after=>[],around=>[],};if (!exists($cache->{"orig"})){no strict 'refs';$cache->{"orig"}=*{$qualified}{CODE};$cache->{"wrapped"}=$cache->{"orig"}|| $hit}if ($type eq 'after'){push @{$cache->{$type}},$code}else {unshift @{$cache->{$type}},$code}if ($type eq 'around'){my$method=$cache->{wrapped};my$attrs=_sub_attrs($code);$cache->{wrapped}=eval "package $into; +sub $attrs { \$code->(\$method, \@_); };"}if (@{$cache->{$type}}==1){my$before=$cache->{"before"};my$after=$cache->{"after"};my$wrapped=\$cache->{"wrapped"};my$attrs=_sub_attrs($cache->{wrapped});my$generated="package $into;\n";$generated .= "sub $name $attrs {";if (@$before){$generated .= '
                      for my $method (@$before) {
                          $method->(@_);
                      }
                  '}if (@$after){$generated .= '
                      my $ret;
                      if (wantarray) {
                          $ret = [$$wrapped->(@_)];
                          '.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
                      }
                      elsif (defined wantarray) {
                          $ret = \($$wrapped->(@_));
                      }
                      else {
                          $$wrapped->(@_);
                      }
  
                      for my $method (@$after) {
                          $method->(@_);
                      }
  
                      wantarray ? @$ret : $ret ? $$ret : ();
                  '}else {$generated .= '$$wrapped->(@_);'}$generated .= '}';no strict 'refs';no warnings 'redefine';no warnings 'closure';eval$generated}}}sub before {_install_modifier(scalar(caller),'before',@_)}sub after {_install_modifier(scalar(caller),'after',@_)}sub around {_install_modifier(scalar(caller),'around',@_)}sub fresh {my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';_fresh(scalar(caller),$code,@names)}sub _fresh {my ($into,$code,@names)=@_;for my$name (@names){if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms){require Carp;Carp::confess("Invalid method name '$name'")}if ($into->can($name)){require Carp;Carp::confess("Class $into already has a method named '$name'")}if (_is_in_package($code,$into)){no strict 'refs';*{"$into\::$name"}=$code}else {no warnings 'closure';my$attrs=_sub_attrs($code);eval "package $into; sub $name $attrs { \$code->(\@_) }"}}}sub _sub_attrs {my ($coderef)=@_;local*_sub=$coderef;local $@;(eval 'sub { _sub = 1 }')? ':lvalue' : ''}sub _is_in_package {my ($coderef,$package)=@_;require B;my$cv=B::svref_2object($coderef);return$cv->GV->STASH->NAME eq $package}1;
CLASS_METHOD_MODIFIERS

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;use warnings;package Data::OptList;$Data::OptList::VERSION='0.110';use List::Util ();use Params::Util ();use Sub::Install 0.921 ();my%test_for;BEGIN {%test_for=(CODE=>\&Params::Util::_CODELIKE,HASH=>\&Params::Util::_HASHLIKE,ARRAY=>\&Params::Util::_ARRAYLIKE,SCALAR=>\&Params::Util::_SCALAR0,)}sub mkopt {my ($opt_list)=shift;my ($moniker,$require_unique,$must_be);my ($name_test,$is_a);if (@_){if (@_==1 and Params::Util::_HASHLIKE($_[0])){($moniker,$require_unique,$must_be,$name_test)=@{$_[0]}{qw(moniker require_unique must_be name_test) }}else {($moniker,$require_unique,$must_be)=@_}if (defined$must_be){$must_be=[$must_be ]unless ref$must_be;my@checks=map {my$class=$_;$test_for{$_}|| sub {$_[1]=$class;goto \&Params::Util::_INSTANCE}}@$must_be;$is_a=(@checks==1)? $checks[0]: sub {my$value=$_[0];List::Util::first {defined($_->($value))}@checks};$moniker='unnamed' unless defined$moniker}}return []unless$opt_list;$name_test ||= sub {!ref $_[0]};$opt_list=[map {$_=>(ref$opt_list->{$_}? $opt_list->{$_}: ())}keys %$opt_list ]if ref$opt_list eq 'HASH';my@return;my%seen;for (my$i=0;$i < @$opt_list;$i++){my$name=$opt_list->[$i];if ($require_unique){Carp::croak "multiple definitions provided for $name" if$seen{$name}++}my$value;if ($i < $#$opt_list){if (not defined$opt_list->[$i+1]){$i++}elsif (!$name_test->($opt_list->[$i+1])){$value=$opt_list->[++$i];if ($is_a &&!$is_a->($value)){my$ref=ref$value;Carp::croak "$ref-ref values are not valid in $moniker opt list"}}}push@return,[$name=>$value ]}return \@return}sub mkopt_hash {my ($opt_list,$moniker,$must_be)=@_;return {}unless$opt_list;$opt_list=mkopt($opt_list,$moniker,1,$must_be);my%hash=map {$_->[0]=>$_->[1]}@$opt_list;return \%hash}BEGIN {*import=Sub::Install::exporter {exports=>[qw(mkopt mkopt_hash)],}}1;
DATA_OPTLIST

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.14';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Getopt/Long/Descriptive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE';
  use strict;use warnings;package Getopt::Long::Descriptive;$Getopt::Long::Descriptive::VERSION='0.101';use Carp qw(carp croak);use File::Basename ();use Getopt::Long 2.33;use List::Util qw(first);use Params::Validate 0.97 qw(:all);use Scalar::Util ();use Getopt::Long::Descriptive::Opts;use Getopt::Long::Descriptive::Usage;my$prog_name;sub prog_name {@_ ? ($prog_name=shift): $prog_name}BEGIN {prog_name(File::Basename::basename($0))}use Sub::Exporter::Util ();use Sub::Exporter 0.972 -setup=>{exports=>[describe_options=>\'_build_describe_options',q(prog_name),@{$Params::Validate::EXPORT_TAGS{types}}],groups=>[default=>[qw(describe_options) ],types=>$Params::Validate::EXPORT_TAGS{types},],};my%CONSTRAINT=(implies=>\&_mk_implies,required=>{optional=>0 },only_one=>\&_mk_only_one,);our$MungeOptions=1;sub _nohidden {return grep {!$_->{constraint}->{hidden}}@_}sub _expand {return map {{(spec=>$_->[0]|| '',desc=>@$_ > 1 ? $_->[1]: 'spacer',constraint=>$_->[2]|| {},name=>@$_ ? _munge((split /[:=|!+]/,$_->[0]|| '')[0]): '',)}}@_}my%HIDDEN=(hidden=>1,);my$SPEC_RE=qr{(?:[:=][0-9\w\+]+[%@]?(\{[0-9]*,[0-9]*\})?|[!+])$};sub _strip_assignment {my ($self,$str)=@_;(my$copy=$str)=~ s{$SPEC_RE}{};if (wantarray){my$len=length$copy;my$assignment=substr$str,$len;if (!defined($assignment)){$assignment=''}return ($copy,$assignment)}return$copy}sub describe_options {my$sub=__PACKAGE__->_build_describe_options(describe_options=>{}=>{});$sub->(@_)}sub usage_class {'Getopt::Long::Descriptive::Usage'}sub _build_describe_options {my ($class)=@_;sub {my$format=shift;my$arg=(ref $_[-1]and ref $_[-1]eq 'HASH')? pop @_ : {};my@opts;my%parent_of;my%method_map;for my$opt (_expand(@_)){$method_map{$opt->{name}}=undef unless$opt->{desc}eq 'spacer';if (ref($opt->{desc})eq 'ARRAY'){$opt->{constraint}->{one_of}=delete$opt->{desc};$opt->{desc}='hidden'}if ($HIDDEN{$opt->{desc}}){$opt->{constraint}->{hidden}++}if ($opt->{constraint}->{one_of}){for my$one_opt (_expand(@{delete$opt->{constraint}->{one_of}})){$parent_of{$one_opt->{name}}=$opt->{name};$one_opt->{constraint}->{implies}->{$opt->{name}}=$one_opt->{name};for my$wipe (qw(required default)){if ($one_opt->{constraint}->{$wipe}){carp "'$wipe' constraint does not make sense in sub-option";delete$one_opt->{constraint}->{$wipe}}}$one_opt->{constraint}->{one_of}=$opt->{name};push@opts,$one_opt}}if ($opt->{constraint}{shortcircuit}&& exists$opt->{constraint}{default}){carp('option "' .$opt->{name}.q[": 'default' does not make sense for shortcircuit options])}push@opts,$opt}my@go_conf=@{$arg->{getopt_conf}|| $arg->{getopt}|| []};if ($arg->{getopt}){warn "describe_options: 'getopt' is deprecated, please use 'getopt_conf' instead\n"}push@go_conf,"bundling" unless grep {/bundling/i}@go_conf;push@go_conf,"no_auto_help" unless grep {/no_auto_help/i}@go_conf;push@go_conf,"no_ignore_case" unless grep {/no_ignore_case/i}@go_conf;my@getopt_specs=map {$_->{spec}}grep {$_->{desc}ne 'spacer'}@opts;my@specs=map {$_->{spec}}grep {$_->{desc}ne 'spacer'}_nohidden(@opts);my$short=join q{},sort {lc$a cmp lc$b or $a cmp $b}grep {/^.$/}map {split /\|/}map {scalar __PACKAGE__->_strip_assignment($_)}@specs;my$long=grep /\b[^|]{2,}/,@specs;my%replace=("%"=>"%","c"=>prog_name,"o"=>join(q{ },($short ? "[-$short]" : ()),($long ? "[long options...]" : ())),);(my$str=$format)=~ s<%(.)><
        defined $replace{$1}
        ? $replace{$1}
        : Carp::croak("unknown sequence %$1 in first argument to describe_options")
      >ge;$str =~ s/[\x20\t]{2,}/ /g;my$usage=$class->usage_class->new({options=>[_nohidden(@opts)],leader_text=>$str,show_defaults=>$arg->{show_defaults},});Getopt::Long::Configure(@go_conf);my%return;$usage->die unless GetOptions(\%return,grep {length}@getopt_specs);my@given_keys=keys%return;for my$opt (keys%return){my$newopt=_munge($opt);next if$newopt eq $opt;$return{$newopt}=delete$return{$opt}}for my$copt (sort {($b->{constraint}{shortcircuit}|| 0)<=> ($a->{constraint}{shortcircuit}|| 0)}grep {$_->{constraint}}@opts){delete$copt->{constraint}->{hidden};my$is_shortcircuit=delete$copt->{constraint}{shortcircuit};my$name=$copt->{name};my$new=_validate_with(name=>$name,params=>\%return,spec=>$copt->{constraint},opts=>\@opts,usage=>$usage,given_keys=>\@given_keys,parent_of=>\%parent_of,);next unless (defined($new)|| exists($return{$name}));$return{$name}=$new;if ($is_shortcircuit){%return=($name=>$return{$name});last}}my$opt_obj=Getopt::Long::Descriptive::Opts->___new_opt_obj({values=>{%method_map,%return },given=>{map {;$_=>1}@given_keys },});return($opt_obj,$usage)}}sub _munge {my ($opt)=@_;return$opt unless$MungeOptions;$opt=lc($opt);$opt =~ tr/-/_/;return$opt}sub _validate_with {my (%arg)=validate(@_,{name=>1,params=>1,spec=>1,opts=>1,usage=>1,given_keys=>1,parent_of=>1,});my$spec=$arg{spec};my%pvspec;for my$ct (keys %{$spec}){if ($CONSTRAINT{$ct}and ref$CONSTRAINT{$ct}eq 'CODE'){$pvspec{callbacks}||= {};$pvspec{callbacks}={%{$pvspec{callbacks}},$CONSTRAINT{$ct}->($arg{name},$spec->{$ct},$arg{params},$arg{opts},),}}else {%pvspec=(%pvspec,$CONSTRAINT{$ct}? %{$CONSTRAINT{$ct}}: ($ct=>$spec->{$ct}),)}}$pvspec{optional}=1 unless exists$pvspec{optional};if (!defined($arg{params}{$arg{name}})&& $pvspec{default}&& $spec->{implies}){$arg{params}{$arg{name}}=delete$pvspec{default}}my%p;my$ok=eval {%p=validate_with(params=>[%{$arg{params}},'-given_keys',$arg{given_keys},'-parent_of',$arg{parent_of},],spec=>{$arg{name}=>\%pvspec },allow_extra=>1,on_fail=>sub {my$fail_msg=shift;Getopt::Long::Descriptive::_PV_Error->throw($fail_msg)},);1};if (!$ok){my$error=$@;if (Scalar::Util::blessed($error)&& $error->isa('Getopt::Long::Descriptive::_PV_Error')){$arg{usage}->die({pre_text=>$error->error ."\n" })}die $@}return$p{$arg{name}}}sub _norm_imply {my ($what)=@_;return {$what=>1 }unless my$ref=ref$what;return$what if$ref eq 'HASH';return {map {$_=>1}@$what }if$ref eq 'ARRAY';die "can't imply: $what"}sub _mk_implies {my$name=shift;my$what=_norm_imply(shift);my$param=shift;my$opts=shift;for my$implied (keys %$what){die("option specification for $name implies nonexistent option $implied\n")unless first {$_->{name}eq $implied}@$opts}my$whatstr=join(q{, },map {"$_=$what->{$_}"}keys %$what);return "$name implies $whatstr"=>sub {my ($pv_val,$rest)=@_;return 1 unless defined$pv_val;while (my ($key,$val)=each %$what){my$parent=$rest->{'-parent_of'}{$name};my@siblings=$parent ? (grep {;defined$rest->{'-parent_of'}{$_}&& $rest->{'-parent_of'}{$_}eq $parent}@{$rest->{'-given_keys'}}): ();if (@siblings > 1){die "these options conflict; each wants to set the $parent: @siblings\n"}if (exists$param->{$key}and $param->{$key}ne $val and grep {;$_ eq $key}@{$rest->{'-given_keys'}}){die("option specification for $name implies that $key should be " ."set to '$val', but it is '$param->{$key}' already\n")}$param->{$key}=$val}return 1}}sub _mk_only_one {die "unimplemented"}{package Getopt::Long::Descriptive::_PV_Error;sub error {$_[0]->{error}}sub throw {my ($class,$error_msg)=@_;my$self={error=>$error_msg };bless$self,$class;die$self}}1;
GETOPT_LONG_DESCRIPTIVE

$fatpacked{"Getopt/Long/Descriptive/Opts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_OPTS';
  use strict;use warnings;package Getopt::Long::Descriptive::Opts;$Getopt::Long::Descriptive::Opts::VERSION='0.101';use Scalar::Util qw(blessed weaken);my%_CREATED_OPTS;my$SERIAL_NUMBER=1;sub _specified {my ($self,$name)=@_;my$meta=$_CREATED_OPTS{blessed$self }{meta};return$meta->{given}{$name }}sub _specified_opts {my ($self)=@_;my$class=blessed$self;my$meta=$_CREATED_OPTS{$class }{meta};return$meta->{specified_opts}if$meta->{specified_opts};my@keys=grep {$meta->{given}{$_ }}(keys %{$meta->{given}});my%opts;@opts{@keys }=@$self{@keys };$meta->{specified_opts}=\%opts;bless$meta->{specified_opts}=>$class;weaken$meta->{specified_opts};$meta->{specified_opts}}sub _complete_opts {my ($self)=@_;my$class=blessed$self;my$meta=$_CREATED_OPTS{$class }{meta};return$meta->{complete_opts}}sub ___class_for_opt {my ($class,$arg)=@_;my$values=$arg->{values};my@bad=grep {$_ !~ /^[a-z_]\w*$/}keys %$values;Carp::confess("perverse option names given: @bad")if@bad;my$new_class="$class\::__OPT__::" .$SERIAL_NUMBER++;$_CREATED_OPTS{$new_class }={meta=>$arg };{no strict 'refs';${"$new_class\::VERSION"}=$class->VERSION;*{"$new_class\::ISA"}=['Getopt::Long::Descriptive::Opts' ];for my$opt (keys %$values){*{"$new_class\::$opt"}=sub {$_[0]->{$opt }}}}return$new_class}sub ___new_opt_obj {my ($class,$arg)=@_;my$copy={%{$arg->{values}}};my$new_class=$class->___class_for_opt($arg);delete$copy->{$_}for grep {!defined$copy->{$_}}keys %$copy;my$self=bless$copy=>$new_class;$_CREATED_OPTS{$new_class }{meta}{complete_opts}=$self;return$self}1;
GETOPT_LONG_DESCRIPTIVE_OPTS

$fatpacked{"Getopt/Long/Descriptive/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_USAGE';
  use strict;use warnings;package Getopt::Long::Descriptive::Usage;$Getopt::Long::Descriptive::Usage::VERSION='0.101';use List::Util qw(max);sub new {my ($class,$arg)=@_;my@to_copy=qw(options leader_text show_defaults);my%copy;@copy{@to_copy }=@$arg{@to_copy };bless \%copy=>$class}sub text {my ($self)=@_;return join qq{\n},$self->leader_text,$self->option_text}sub leader_text {$_[0]->{leader_text}}sub option_text {my ($self)=@_;my@options=@{$self->{options}|| []};my$string=q{};my@specs=map {$_->{spec}}grep {$_->{desc}ne 'spacer'}@options;my$length=(max(map {_option_length($_)}@specs)|| 0);my$spec_fmt="\t%-${length}s";while (@options){my$opt=shift@options;my$spec=$opt->{spec};my$desc=$opt->{desc};my$assign;if ($desc eq 'spacer'){$string .= sprintf "$spec_fmt\n",$opt->{spec};next}($spec,$assign)=Getopt::Long::Descriptive->_strip_assignment($spec);$assign=_parse_assignment($assign);$spec=join " ",reverse map {length > 1 ? "--${_}$assign" : "-${_}$assign"}split /\|/,$spec;my@desc=$self->_split_description($length,$desc);if (exists$opt->{constraint}->{default}and $self->{show_defaults}){my$dflt=$opt->{constraint}->{default};$dflt=!defined$dflt ? '(undef)' :!length$dflt ? '(empty string)' : $dflt;push@desc,"(default value: $dflt)"}$string .= sprintf "$spec_fmt  %s\n",$spec,shift@desc;for my$line (@desc){$string .= "\t";$string .= q{ } x ($length + 2);$string .= "$line\n"}}return$string}sub _option_length {my ($fullspec)=@_;my$number_opts=1;my$last_pos=0;my$number_shortopts=0;my ($spec,$argspec)=Getopt::Long::Descriptive->_strip_assignment($fullspec);my$length=length$spec;my$arglen=length(_parse_assignment($argspec));while ($spec =~ m{\|}g){$number_opts++;if (pos($spec)- $last_pos==2){$number_shortopts++}$last_pos=pos($spec)}if ($length - $last_pos==1){$number_shortopts++}my$number_longopts=$number_opts - $number_shortopts;my$total_arglen=$number_opts * $arglen;my$total_optsep=2 * $number_longopts + $number_shortopts;my$total=$length + $total_optsep + $total_arglen;return$total}sub _split_description {my ($self,$length,$desc)=@_;my$max_length=78 - ($length + 8 + 2);return$desc if length$desc <= $max_length;my@lines;while (length$desc > $max_length){my$idx=rindex(substr($desc,0,$max_length),q{ },);last unless$idx >= 0;push@lines,substr($desc,0,$idx);substr($desc,0,$idx + 1)=q{}}push@lines,$desc;return@lines}sub _parse_assignment {my ($assign_spec)=@_;my$argument;my$result='STR';my$desttype;if (length($assign_spec)< 2){return ''}$argument=substr$assign_spec,1,2;if ($argument =~ m/^i/ or $argument =~ m/^o/){$result='INT'}elsif ($argument =~ m/^f/){$result='NUM'}if (length($assign_spec)> 2){$desttype=substr($assign_spec,2,1);if ($desttype eq '@'){$result .= '...'}elsif ($desttype eq '%'){$result="KEY=${result}..."}}if (substr($assign_spec,0,1)eq ':'){return "[=$result]"}return " $result"}sub warn {warn shift->text}sub die {my$self=shift;my$arg=shift || {};die(join q{},grep {defined}$arg->{pre_text},$self->text,$arg->{post_text})}use overload (q{""}=>"text",'&{}'=>sub {my ($self)=@_;Carp::cluck("use of __PACKAGE__ objects as a code ref is deprecated");return sub {return $_[0]? $self->text : $self->warn}});1;
GETOPT_LONG_DESCRIPTIVE_USAGE

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use Moo::_strictures;use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);use Scalar::Util 'blessed';use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::_Utils)}BEGIN {*_CAN_WEAKEN_READONLY=("$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583})? sub(){0}: sub(){1};our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')});our$CAN_HAZ_XS_PRED=$CAN_HAZ_XS && (eval {Class::XSAccessor->VERSION('1.17')})}BEGIN {package Method::Generate::Accessor::_Generated;$Carp::Internal{+__PACKAGE__}=1}my$module_name_only=qr/\A$Module::Runtime::module_name_rx\z/;sub _die_overwrite {my ($pkg,$method,$type)=@_;croak "You cannot overwrite a locally defined method ($method) with " .($type || 'an accessor')}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={no_defer=>1,package=>'Method::Generate::Accessor::_Generated',%{$quote_opts||{}},};$spec->{allow_overwrite}++ if$name =~ s/^\+//;croak "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||= '_build_'.$name unless exists$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){croak "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;croak "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ $module_name_only}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}if (($spec->{coerce}||0)eq 1){my$isa=$spec->{isa};if (blessed$isa and $isa->can('coercion')){$spec->{coerce}=$isa->coercion}elsif (blessed$isa and $isa->can('coerce')){$spec->{coerce}=sub {$isa->coerce(@_)}}else {croak "Invalid coercion for $into->$name - no appropriate type constraint"}}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& defined &{"${into}::${reader}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& defined &{"${into}::${accessor}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& defined &{"${into}::${writer}"};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& defined &{"${into}::${pred}"};if (our$CAN_HAZ_XS && our$CAN_HAZ_XS_PRED){$methods{$pred}=$self->_generate_xs(exists_predicates=>$into,$pred,$name,$spec)}else {$self->{captures}={};$methods{$pred}=quote_sub "${into}::${pred}" =>$self->_generate_simple_has('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }}if (my$builder=delete$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$builder)}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& defined &{"${into}::${cl}"};$self->{captures}={};$methods{$cl}=quote_sub "${into}::${cl}" =>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||= '_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){require Moo::Role;_load_module$hspec;map [$_=>$_ ],Moo::Role->methods_provided_by($hspec)}else {croak "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& defined &{"${into}::${proxy}"};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}" =>$self->_generate_delegation($asserter,$target,\@args)=>delete$self->{captures}=>$quote_opts }}if (my$asserter=$spec->{asserter}){_die_overwrite($into,$asserter,'an asserter')if!$spec->{allow_overwrite}&& defined &{"${into}::${asserter}"};local$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}" =>$self->_generate_asserter($name,$spec)=>delete$self->{captures}=>$quote_opts }\%methods}sub merge_specs {my ($self,@specs)=@_;my$spec=shift@specs;for my$old_spec (@specs){for my$key (keys %$old_spec){if ($key eq 'handles'){}elsif ($key eq 'moosify'){$spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}grep defined,($old_spec->{$key},$spec->{$key})]}elsif (!exists$spec->{$key}){$spec->{$key}=$old_spec->{$key}}}}$spec}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_default {my ($self,$name,$spec)=@_;$spec->{builder}or exists$spec->{default}or (($spec->{is}||'')eq 'lazy')}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\quotify $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\quotify $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): quotify$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_simple_get(@args);($code,delete$self->{captures})}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=quotify$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;my ($me,$source)=('$_[0]','$_[1]');if ($self->is_simple_set($name,$spec)){return$self->_generate_simple_set($me,$name,$spec,$source)}my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};if ($coerce){$source=$self->_generate_coerce($name,$source,$coerce)}if ($isa_check){'scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$isa_check)."),\n" .'  ('.$self->_generate_simple_set($me,$name,$spec,'$value')."),\n" .($trigger ? '('.$self->_generate_trigger($name,$me,'$value',$trigger)."),\n" : '').'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" ."}"}elsif ($trigger){my$set=$self->_generate_simple_set($me,$name,$spec,$source);"scalar (\n" .'  ('.$self->_generate_trigger($name,$me,"($set)",$trigger)."),\n" .'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" .")"}else {'('.$self->_generate_simple_set($me,$name,$spec,$source).')'}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return quotify($name)if!defined($init_arg)or $init_arg eq $name;return quotify($name).' (constructor argument: '.quotify($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_wrap_attr_exception($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce),1,)}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _wrap_attr_exception {my ($self,$name,$step,$arg,$code,$want_return)=@_;my$prefix=quotify("${step} for "._attr_desc($name,$arg).' failed: ');"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n" .'    init_arg => '.quotify($arg).",\n" .'    name     => '.quotify($name).",\n" .'    step     => '.quotify($step).",\n" ."  };\n" .($want_return ? '  (my $_return),'."\n" : '').'  (my $_error), (my $_old_error = $@);'."\n" ."  (eval {\n" .'    ($@ = $_old_error),'."\n" .'    (' .($want_return ? '$_return ='."\n" : '').$code."),\n" ."    1\n" ."  } or\n" .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n" .'  ($@ = $_old_error),'."\n" .'  (defined $_error and CORE::die $_error);'."\n" .($want_return ? '  $_return;'."\n" : '')."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_wrap_attr_exception($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub _sanitize_name {sanitize_identifier($_[1])}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;my$has_default=$self->has_eager_default($name,$spec);if (!($has_default || $test)){return ''}if ($has_default){my$get_default=$self->_generate_get_default($me,$name,$spec);$source=$test ? "(\n  ${test}\n" ."   ? ${source}\n   : " .$get_default .")" : $get_default}if ($spec->{coerce}){$source=$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg)}if ($spec->{isa}){$source='scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg)."),\n" ."  \$value\n" ."}\n"}my$set=$self->_generate_simple_set($me,$name,$spec,$source);my$trigger=$spec->{trigger}? $self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}): undef;if ($has_default){"($set)," .($trigger && $test ? "($test and $trigger)," : '')."\n"}else {"($test and ($set)" .($trigger ? ", ($trigger)" : '')."),\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple=_CAN_WEAKEN_READONLY ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }" : <<"EOC"}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;my$name_str=quotify($name);"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  ".$self->_generate_simple_has('$_[0]',$name,$spec)."\n" ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$error;if (blessed$value){local $@;no warnings 'void';eval {\&$value;1}and return 1;$error="could not be converted to a coderef: $@"}elsif (ref$value eq 'CODE'){return 1}else {$error='is not a coderef or code-convertible object'}croak "Invalid $setting '" .($INC{'overload.pm'}? overload::StrVal($value): $value)."' for $into " .$error .($appended ? " $appended" : '')}1;
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL" =>join('',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n},)=>{}=>{no_defer=>1 }}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{mro::get_linear_isa($into)};'    (('.$args.')[0]->{__no_BUILD__} or ('."\n" .join('',map qq{      ${me}->${_}(${args}),\n},@builds)."    )),\n"}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use Moo::_strictures;use Sub::Quote qw(quote_sub quotify);use Sub::Defer;use Moo::_Utils qw(_getstash _getglob);use Moo::_mro;use Scalar::Util qw(weaken);use Carp qw(croak);use Carp::Heavy ();BEGIN {our@CARP_NOT=qw(Sub::Defer)}BEGIN {local$Moo::sification::disabled=1;require Moo;Moo->import}sub register_attribute_specs {my ($self,@new_specs)=@_;$self->assert_constructor;my$specs=$self->{attribute_specs}||={};my$ag=$self->accessor_generator;while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){croak "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};$ag->merge_specs($new_spec,$old_spec)}if ($new_spec->{required}&&!($ag->has_default($name,$new_spec)||!exists$new_spec->{init_arg}|| defined$new_spec->{init_arg})){croak "You cannot have a required attribute (${name})" ." without a default, builder, or an init_arg"}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||= $self->_build_construction_string}sub buildall_generator {require Method::Generate::BuildAll;Method::Generate::BuildAll->new}sub _build_construction_string {my ($self)=@_;my$builder=$self->{construction_builder};$builder ? $self->$builder : 'bless(' .$self->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;$self->assert_constructor;my$package=$self->{package};my (undef,@isa)=@{mro::get_linear_isa($package)};my$isa=join ',',@isa;my (undef,$from_file,$from_line)=caller(Carp::short_error_loc());my$constructor=defer_sub "${package}::new"=>sub {my (undef,@new_isa)=@{mro::get_linear_isa($package)};if (join(',',@new_isa)ne $isa){my ($expected_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa;my ($found_new)=grep {*{_getglob($_.'::new')}{CODE}}@new_isa;if (($found_new||'')ne ($expected_new||'')){$found_new ||= 'none';$expected_new ||= 'none';croak "Expected parent constructor of $package to be" ." $expected_new, but found $found_new: changing the inheritance" ." chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported"}}my$constructor=$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1,no_defer=>1 });$self->{inlined}=1;weaken($self->{constructor}=$constructor);$constructor};$self->{inlined}=0;weaken($self->{constructor}=$constructor);$self}sub current_constructor {my ($self,$package)=@_;return *{_getglob("${package}::new")}{CODE}}sub assert_constructor {my ($self)=@_;my$package=$self->{package}or return 1;my$current=$self->current_constructor($package)or return 1;my$constructor=$self->{constructor}or croak "Unknown constructor for $package already exists";croak "Constructor for $package has been replaced with an unknown sub" if$constructor!=$current;croak "Constructor for $package has been inlined and cannot be updated" if$self->{inlined}}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={%{$quote_opts||{}},package=>$into,};for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$into_buildargs=$into->can('BUILDARGS');my$body ='    my $invoker = CORE::shift();'."\n" .'    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n" .$self->_handle_subconstructor($into,$name).($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS ? $self->_generate_args_via_buildargs : $self->_generate_args).$self->_check_required($spec).'    my $new = '.$self->construction_string.";\n" .$self->_assign_new($spec).($into->can('BUILD')? $self->buildall_generator->buildall_body_for($into,'$new','$args'): '').'    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.quotify($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg=$test{$_};my$arg_key=quotify($arg);my$test=defined$arg ? "exists \$args->{$arg_key}" : undef;my$source=defined$arg ? "\$args->{$arg_key}" : undef;my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$arg,))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my$s=$spec->{$_};$s->{required}and not($s->{builder}or exists$s->{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, ' .join(', ',map quotify($_),@required_init).') {'."\n" .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n" ."    }\n"}sub new {my$class=shift;delete _getstash(__PACKAGE__)->{new};bless$class->BUILDARGS(@_),$class}Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },construction_builder=>{is=>'bare' },subconstructor_handler=>{is=>'ro' },package=>{is=>'bare' },);if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__)}1;
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{mro::get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;$Module::Implementation::VERSION='0.09';use strict;use warnings;use Module::Runtime 0.012 qw(require_module);use Try::Tiny;unless (exists$Module::Implementation::{VERSION}&& ${$Module::Implementation::{VERSION}}){$Module::Implementation::{VERSION}=\42}my%Implementation;sub build_loader_sub {my$caller=caller();return _build_loader($caller,@_)}sub _build_loader {my$package=shift;my%args=@_;my@implementations=@{$args{implementations}};my@symbols=@{$args{symbols}|| []};my$implementation;my$env_var=uc$package;$env_var =~ s/::/_/g;$env_var .= '_IMPLEMENTATION';return sub {my ($implementation,$loaded)=_load_implementation($package,$ENV{$env_var},\@implementations,);$Implementation{$package}=$implementation;_copy_symbols($loaded,$package,\@symbols);return$loaded}}sub implementation_for {my$package=shift;return$Implementation{$package}}sub _load_implementation {my$package=shift;my$env_value=shift;my$implementations=shift;if ($env_value){die "$env_value is not a valid implementation for $package" unless grep {$_ eq $env_value}@{$implementations};my$requested="${package}::$env_value";($requested)=$requested =~ /^(.+)$/;try {require_module($requested)}catch {require Carp;Carp::croak("Could not load $requested: $_")};return ($env_value,$requested)}else {my$err;for my$possible (@{$implementations}){my$try="${package}::$possible";my$ok;try {require_module($try);$ok=1}catch {$err .= $_ if defined $_};return ($possible,$try)if$ok}require Carp;if (defined$err && length$err){Carp::croak("Could not find a suitable $package implementation: $err")}else {Carp::croak('Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken')}}}sub _copy_symbols {my$from_package=shift;my$to_package=shift;my$symbols=shift;for my$sym (@{$symbols}){my$type=$sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';my$from="${from_package}::$sym";my$to="${to_package}::$sym";{no strict 'refs';no warnings 'once';*{$to}=$type eq '&' ? \&{$from}: $type eq '$' ? \${$from}: $type eq '@' ? \@{$from}: $type eq '%' ? \%{$from}: $type eq '*' ? *{$from}: die "Can't copy symbol from $from_package to $to_package: $type$sym"}}}1;
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.016";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use Moo::_strictures;use Moo::_mro;use Moo::_Utils qw(_getglob _getstash _install_coderef _install_modifier _load_module _set_loaded _unimport_coderefs);use Scalar::Util qw(reftype);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Method::Generate::Constructor Method::Generate::Accessor Moo::sification Moo::_Utils Moo::Role)}our$VERSION='2.003004';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;our%MAKERS;sub _install_tracked {my ($target,$name,$code)=@_;$MAKERS{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::${name}"=>$code}sub import {my$target=caller;my$class=shift;_set_loaded(caller);strict->import;warnings->import;if ($INC{'Role/Tiny.pm'}and Role::Tiny->is_role($target)){croak "Cannot import Moo into a role"}$MAKERS{$target}||= {};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak "Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};my$stash=_getstash($target);my@not_methods=map +(!ref($_)? *$_{CODE}||(): reftype($_)eq 'CODE' ? $_ : ()),values %$stash;@{$MAKERS{$target}{not_methods}={}}{@not_methods}=@not_methods;$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target,$MAKERS{$target})}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{'Role/Tiny.pm'}&& Role::Tiny->is_role($superclass)){croak "Can't extend role '$superclass'"}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){$old->assert_constructor;delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||= do {my$maker_class=do {if (my$m=do {require Sub::Defer;if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||= do {require Method::Generate::Constructor;my%construct_opts=(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n" .'          package '.$target.';'."\n" .'          return $invoker->SUPER::new(@_);'."\n" .'        }'."\n" .'        '.$class.'->_constructor_maker_for($class);'."\n" .'        return $invoker->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object('."\n" .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n" .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n" .'        );'."\n" .'      }'."\n"),);my$con;my@isa=@{mro::get_linear_isa($target)};shift@isa;no strict 'refs';if (my ($parent_new)=grep +(defined &{$_.'::new'}),@isa){if ($parent_new eq 'Moo::Object'){}elsif (my$makers=$MAKERS{$parent_new}){$con=$makers->{constructor};$construct_opts{construction_string}=$con->construction_string if$con}elsif ($parent_new->can('BUILDALL')){$construct_opts{construction_builder}=sub {my$inv=$target->can('BUILDARGS')? '' : 'Moo::Object::';'do {' .'  my $args = $class->'.$inv.'BUILDARGS(@_);' .'  $args->{__no_BUILD__} = 1;' .'  $invoker->'.$target.'::SUPER::new($args);' .'}'}}else {$construct_opts{construction_builder}=sub {'$invoker->'.$target.'::SUPER::new(' .($target->can('FOREIGNBUILDARGS')? '$class->FOREIGNBUILDARGS(@_)' : '@_').')'}}}($con ? ref($con): 'Method::Generate::Constructor')->new(%construct_opts)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}sub _concrete_methods_of {my ($me,$class)=@_;my$makers=$MAKERS{$class};my$stash=_getstash($class);my$not_methods={reverse %{$makers->{not_methods}||{}}};+{map {;no strict 'refs';my$code=exists &{"${class}::$_"}? \&{"${class}::$_"}: undef;(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep +(!ref($stash->{$_})|| reftype($stash->{$_})eq 'CODE'),keys %$stash }}1;
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use Moo::_strictures;use Moo::_Utils qw(_getstash);use Sub::Quote qw(quotify);use Carp qw(croak);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',keys%Moo::MAKERS;inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor';@Moo::HandleMoose::FakeMeta::ISA='Moose::Meta::Method::Meta'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;require Sub::Defer;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$am_class,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,0,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,1,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,0,Moose::Meta::Class->initialize($name),{},[])}};{local$DID_INJECT{$name}=1;for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods =%{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};if (my$info=$Moo::Role::INFO{$name}){delete$info->{methods}}$methods{$_}=Sub::Defer::undefer_sub($methods{$_})for grep $_ ne 'new',keys%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$attr_name (@$attr_order){$seen_name{$attr_name}=1;my%spec=%{$attr_specs->{$attr_name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||= 'traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();unless (Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")){croak "error inflating attribute '$attr_name' for package '$name': " ."\$TYPE_MAP{$isa} did not return a valid type constraint'"}$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=quotify($attr_name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($attr_name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$attr_name=delete$spec{name};next if$seen_name{$attr_name}++;push@attrs,$meta->add_attribute($attr_name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}elsif ($am_class){for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);my$meta_meth;if ($meta_meth=$meta->find_method_by_name('meta')and $meta_meth->body==\&Moo::Object::meta){bless($meta_meth,'Moo::HandleMoose::FakeMeta')}require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,keys %{$Moo::Role::APPLIED_TO{$name}}}$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;use Moo::_strictures;use Carp ();BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);my$self=shift;Carp::croak "Can't call $meth without object instance" if!ref$self;Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)}sub can {my$self=shift;return$self->SUPER::can(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)}sub isa {my$self=shift;return$self->SUPER::isa(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;use Moo::_strictures;package Moo::HandleMoose;our%TYPE_MAP;package Moo::HandleMoose::_TypeMap;use Scalar::Util ();use Config;our%WEAK_TYPES;sub _str_to_ref {my$in=shift;return$in if ref$in;if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/){my$type=$1;my$id=do {no warnings 'portable';hex "$2"};require B;my$sv=bless \$id,'B::SV';my$ref=eval {$sv->object_2svref};if (!defined$ref or Scalar::Util::reftype($ref)ne $type){die <<'END_ERROR'}return$ref}return$in}sub TIEHASH {bless {},$_[0]}sub STORE {my ($self,$key,$value)=@_;my$type=_str_to_ref($key);$WEAK_TYPES{$type}=$type;Scalar::Util::weaken($WEAK_TYPES{$type})if ref$type;$self->{$key}=$value}sub FETCH {$_[0]->{$_[1]}}sub FIRSTKEY {my$a=scalar keys %{$_[0]};each %{$_[0]}}sub NEXTKEY {each %{$_[0]}}sub EXISTS {exists $_[0]->{$_[1]}}sub DELETE {delete $_[0]->{$_[1]}}sub CLEAR {%{$_[0]}=()}sub SCALAR {scalar %{$_[0]}}sub CLONE {my@types=map {defined$WEAK_TYPES{$_}? ($WEAK_TYPES{$_}=>$TYPE_MAP{$_}): ()}keys%TYPE_MAP;%WEAK_TYPES=();%TYPE_MAP=@types}sub DESTROY {my%types=%{$_[0]};untie%TYPE_MAP;%TYPE_MAP=%types}if ($Config{useithreads}){my@types=%TYPE_MAP;tie%TYPE_MAP,__PACKAGE__;%TYPE_MAP=@types}1;
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use Moo::_strictures;use Carp ();our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}my$proto=$class->BUILDARGS(@_);$NO_BUILD{$class}and return bless({},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({},$class): bless({},$class)->BUILDALL($proto)}sub BUILDARGS {my$class=shift;scalar @_==1 ? ref $_[0]eq 'HASH' ? {%{$_[0]}}: Carp::croak("Single parameters to new() must be a HASH ref" ." data => ".$_[0]): @_ % 2 ? Carp::croak("The new() method for $class expects a hash reference or a" ." key/value list. You passed an odd number of arguments"): {@_}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||= do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {return!!0 unless ($INC{'Moose/Role.pm'}|| $INC{'Role/Tiny.pm'});require Moo::Role;my$does=Moo::Role->can("does_role");{no warnings 'redefine';*does=$does}goto &$does}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use Moo::_strictures;use Moo::_Utils qw(_getglob _getstash _install_coderef _install_modifier _load_module _name_coderef _set_loaded _unimport_coderefs);use Carp qw(croak);use Role::Tiny ();BEGIN {our@ISA=qw(Role::Tiny)}BEGIN {our@CARP_NOT=qw(Method::Generate::Accessor Method::Generate::Constructor Moo::sification Moo::_Utils)}our$VERSION='2.003004';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;BEGIN {*INFO=\%Role::Tiny::INFO;*APPLIED_TO=\%Role::Tiny::APPLIED_TO;*COMPOSED=\%Role::Tiny::COMPOSED;*ON_ROLE_CREATE=\@Role::Tiny::ON_ROLE_CREATE}our%INFO;our%APPLIED_TO;our%APPLY_DEFAULTS;our%COMPOSED;our@ON_ROLE_CREATE;sub _install_tracked {my ($target,$name,$code)=@_;$INFO{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::Role::${name}"=>$code}sub import {my$target=caller;if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){croak "Cannot import Moo::Role into a Moo class"}_set_loaded(caller);goto&Role::Tiny::import}sub _install_subs {my ($me,$target)=@_;_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;($INFO{$target}{accessor_maker}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new})->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)}}_install_tracked$target=>requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)};_install_tracked$target=>with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)};*{_getglob("${target}::meta")}=$me->can('meta')}push@ON_ROLE_CREATE,sub {my$target=shift;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}};sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target,$INFO{$target})}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub methods_provided_by {my ($self,$role)=@_;_load_module($role);$self->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$self->is_role($role);return$self->SUPER::methods_provided_by($role)}sub is_role {my ($self,$role)=@_;$self->_inhale_if_moose($role);$self->SUPER::is_role($role)}sub _inhale_if_moose {my ($self,$role)=@_;my$meta;if (!$self->SUPER::is_role($role)and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){my$is_mouse=$meta->isa('Mouse::Meta::Role');$INFO{$role}{methods}={map +($_=>$role->can($_)),grep$role->can($_),grep!($is_mouse && $_ eq 'meta'),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){require Sub::Quote;my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;my$tc_var='$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);$spec->{isa}=Sub::Quote::quote_sub(qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },{$tc_var=>\$check },{package=>$role,},);if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub _undefer_subs {my ($self,$target,$role)=@_;if ($INC{'Sub/Defer.pm'}){Sub::Defer::undefer_package($role)}}sub role_application_steps {qw(_handle_constructor _undefer_subs _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role);$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){@{*{_getglob("${new_name}::ISA")}{ARRAY}}=($superclass);$Moo::MAKERS{$new_name}={is_class=>1};$me->apply_roles_to_package($new_name,@roles)}else {$me->SUPER::create_class_with_roles($superclass,@roles);$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($new_name)}$COMPOSED{class}{$new_name}=1;_set_loaded($new_name,(caller)[1]);return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);my$class=ref$new;_set_loaded($class,(caller)[1]);my$apply_defaults=exists$APPLY_DEFAULTS{$class}? $APPLY_DEFAULTS{$class}: $APPLY_DEFAULTS{$class}=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for($class)and my$m=Moo->_accessor_maker_for($class)){my$specs=$con_gen->all_attribute_specs;my%captures;my$code=join('',(map {my$name=$_;my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($set,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap);"($set),"}else {()}}sort keys%attrs),);if ($code){require Sub::Quote;Sub::Quote::quote_sub("${class}::_apply_defaults","no warnings 'void';\n$code",\%captures,{package=>$class,no_install=>1,})}else {0}}else {0}};if ($apply_defaults){local$Carp::Internal{+__PACKAGE__}=1;local$Carp::Internal{$class}=1;$new->$apply_defaults}return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _install_does {my ($me,$to)=@_;my$new=$me->SUPER::_install_does($to)or return;return _name_coderef("${to}::DOES",$new)}sub does_role {my ($proto,$role)=@_;return 1 if Role::Tiny::does_role($proto,$role);my$meta;if ($INC{'Moose.pm'}and $meta=Class::MOP::class_of($proto)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->can('does_role')){return$meta->does_role($role)}return 0}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;my$info=$INFO{$to};my$con=$INC{"Moo.pm"}&& Moo->_constructor_maker_for($to);my%existing =$info ? @{$info->{attributes}|| []}: $con ? %{$con->all_attribute_specs || {}}: ();my@attr_info=map {@{$attr_info}[$_,$_+1]}grep {!$existing{$attr_info->[$_]}}map {2 * $_}0..@$attr_info/2-1;if ($info){push @{$info->{attributes}||=[]},@attr_info}elsif ($con){$con->register_attribute_specs(map ref()? {%$_ }: $_,@attr_info)}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;use Moo::_strictures;{no strict 'refs';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}}BEGIN {my ($su,$sn);$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname or $sn=$INC{'Sub/Name.pm'}or $su=eval {require Sub::Util}&& defined&Sub::Util::set_subname or $sn=eval {require Sub::Name};*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_CAN_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}use Module::Runtime qw(use_package_optimistically module_notional_filename);use Devel::GlobalDestruction ();use Exporter qw(import);use Config;use Carp qw(croak);our@EXPORT=qw(_getglob _install_modifier _load_module _maybe_load_module _getstash _install_coderef _name_coderef _unimport_coderefs _set_loaded);sub _install_modifier {my ($into,$type,$name,$code)=@_;if ($INC{'Sub/Defer.pm'}and my$to_modify=$into->can($name)){Sub::Defer::undefer_sub($to_modify)}require Class::Method::Modifiers;Class::Method::Modifiers::install_modifier(@_)}sub _load_module {my$module=$_[0];my$file=eval {module_notional_filename($module)}or croak $@;use_package_optimistically($module);return 1 if$INC{$file};my$error=$@ || "Can't locate $file";my$stash=_getstash($module)||{};return 1 if grep +(ref($_)|| *$_{CODE}),values %$stash;return 1 if$INC{"Moose.pm"}&& Class::MOP::class_of($module)or Mouse::Util->can('find_meta')&& Mouse::Util::find_meta($module);croak$error}our%MAYBE_LOADED;sub _maybe_load_module {my$module=$_[0];return$MAYBE_LOADED{$module}if exists$MAYBE_LOADED{$module};if(!eval {use_package_optimistically($module)}){warn "$module exists but failed to load with error: $@"}elsif ($INC{module_notional_filename($module)}){return$MAYBE_LOADED{$module}=1}return$MAYBE_LOADED{$module}=0}sub _set_loaded {$INC{Module::Runtime::module_notional_filename($_[0])}||= $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _unimport_coderefs {my ($target,$info)=@_;return unless$info and my$exports=$info->{exports};my%rev=reverse %$exports;my$stash=_getstash($target);for my$name (keys %$exports){if ($stash->{$name}and defined(&{$stash->{$name}})){if ($rev{$target->can($name)}){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}}}if ($Config{useithreads}){require Moo::HandleMoose::_TypeMap}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;use Moo::_strictures;if ("$]" >= 5.010_000){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;use strict;use warnings;sub import {if ($ENV{MOO_FATAL_WARNINGS}){require strictures;strictures->VERSION(2);@_=('strictures');goto&strictures::import}else {strict->import;warnings->import;warnings->unimport('once')}}1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use Moo::_strictures;no warnings 'once';use Devel::GlobalDestruction qw(in_global_destruction);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub unimport {croak "Can't disable Moo::sification after inflation has been done" if$Moo::HandleMoose::SETUP_DONE;our$disabled=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disabled or in_global_destruction){require Moo::HandleMoose;Moo::HandleMoose->import}}sub import {return if our$setup_done;if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}$setup_done=1}1;
MOO_SIFICATION

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.104';use Config;use Exporter 5.57 (qw/import/);use File::Spec 0.86 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_BSD=>(scalar $^O =~ /bsd$/),IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);sub FREEZE {return $_[0]->[PATH]}sub THAW {return path($_[2])}{no warnings 'once';*TO_JSON=*FREEZE};my$HAS_UU;sub _check_UU {!!eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_PU;sub _check_PU {!!eval {require PerlIO::utf8_strict;PerlIO::utf8_strict->VERSION(0.003);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?$}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT$/): ($_[0]eq '/')}BEGIN {*_same=IS_WIN32()? sub {lc($_[0])eq lc($_[1])}: sub {$_[0]eq $_[1]}}my%MODEBITS=(om=>0007,gm=>0070,um=>0700);{my$m=0;$MODEBITS{$_}=(1 << $m++)for qw/ox ow or gx gw gr ux uw ur/};sub _symbolic_chmod {my ($mode,$symbolic)=@_;for my$clause (split /,\s*/,$symbolic){if ($clause =~ m{\A([augo]+)([=+-])([rwx]+)\z}){my ($who,$action,$perms)=($1,$2,$3);$who =~ s/a/ugo/g;for my$w (split //,$who){my$p=0;$p |= $MODEBITS{"$w$_"}for split //,$perms;if ($action eq '='){$mode=($mode & ~$MODEBITS{"${w}m"})| $p}else {$mode=$action eq "+" ? ($mode | $p): ($mode & ~$p)}}}else {Carp::croak("Invalid mode clause '$clause' for chmod()")}}return$mode}{package flock;use if Path::Tiny::IS_BSD(),'warnings::register'}my$WARNED_BSD_NFS=0;sub _throw {my ($self,$function,$file,$msg)=@_;if (IS_BSD()&& $function =~ /^flock/ && $! =~ /operation not supported/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_BSD_NFS){warnings::warn(flock=>"No flock for NFS on BSD: continuing in unsafe mode");$WARNED_BSD_NFS++}}else {$msg=$! unless defined$msg;Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$msg)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("Path::Tiny paths require defined, positive-length parts")unless 1 + @_==grep {defined && length}$path,@_;if (!@_ && ref($path)eq __PACKAGE__ &&!$path->[TEMP]){return$path}$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};$path .= "/" if$path =~ m{^$UNC_VOL$}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path="/" if$path eq '/..';$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL$};if (_is_root($path)){$path =~ s{/?$}{/}}else {$path =~ s{/$}{}}if ($path =~ m{^(~[^/]*).*}){require File::Glob;my ($homedir)=File::Glob::bsd_glob($1);$homedir =~ tr[\\][/] if IS_WIN32();$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;$temp->{REALNAME}=$self->[CANON]if IS_WIN32;return$self}sub _parse_file_temp_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return (\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub _resolve_symlinks {my ($self)=@_;my$new=$self;my ($count,%seen)=0;while (-l $new->[PATH]){if ($seen{$new->[PATH]}++){$self->_throw('readlink',$self->[PATH],"symlink loop detected")}if (++$count > 100){$self->_throw('readlink',$self->[PATH],"maximum symlink depth exceeded")}my$resolved=readlink$new->[PATH]or $new->_throw('readlink',$new->[PATH]);$resolved=path($resolved);$new=$resolved->is_absolute ? $resolved : $new->sibling($resolved)}return$new}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path(Cwd::getcwd(),$_[0]->[PATH])unless defined$base;$base=path($base);return path(($base->is_absolute ? $base : $base->absolute),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$mode=$args->{truncate}? ">" : ">>";my$fh=$self->filehandle({locked=>1 },$mode,$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);$args->{binmode}=':unix';append($self,$args,@data)}sub append_utf8 {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){$args->{binmode}=":unix";append($self,$args,map {Unicode::UTF8::encode_utf8($_)}@data)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";append($self,$args,@data)}else {$args->{binmode}=":unix:encoding(UTF-8)";append($self,$args,@data)}}sub assert {my ($self,$assertion)=@_;return$self unless$assertion;if (ref$assertion eq 'CODE'){local $_=$self;$assertion->()or Path::Tiny::Error->throw("assert",$self->[PATH],"failed assertion")}else {Carp::croak("argument to assert must be a code reference argument")}return$self}sub basename {my ($self,@suffixes)=@_;$self->_splitpath unless defined$self->[FILE];my$file=$self->[FILE];for my$s (@suffixes){my$re=ref($s)eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;last if$file =~ s/$re//}return$file}sub canonpath {$_[0]->[CANON]}sub cached_temp {my$self=shift;$self->_throw("cached_temp",$self,"has no cached File::Temp object")unless defined$self->[TEMP];return$self->[TEMP]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub chmod {my ($self,$new_mode)=@_;my$mode;if ($new_mode =~ /\d/){$mode=($new_mode =~ /^0/ ? oct($new_mode): $new_mode)}elsif ($new_mode =~ /[=+-]/){$mode=_symbolic_chmod($self->stat->mode & 07777,$new_mode)}else {Carp::croak("Invalid mode argument '$new_mode' for chmod()")}CORE::chmod($mode,$self->[PATH])or $self->_throw("chmod");return 1}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!");return -d $dest ? path($dest,$self->basename): path($dest)}sub digest {my ($self,@opts)=@_;my$args=(@opts && ref$opts[0]eq 'HASH')? shift@opts : {};$args=_get_args($args,qw/chunk_size/);unshift@opts,'SHA-256' unless@opts;require Digest;my$digest=Digest->new(@opts);if ($args->{chunk_size}){my$fh=$self->filehandle({locked=>1 },"<",":unix");my$buf;$digest->add($buf)while read$fh,$buf,$args->{chunk_size}}else {$digest->add($self->slurp_raw)}return$digest->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub edit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp(exists($args->{binmode})? {binmode=>$args->{binmode}}: ());$cb->();$self->spew($args,$_);return}sub edit_utf8 {my ($self,$cb)=@_;Carp::croak("Callback for edit_utf8() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp_utf8;$cb->();$self->spew_utf8($_);return}sub edit_raw {$_[2]={binmode=>":unix" };goto&edit}sub edit_lines {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit_lines() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$temp_fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);my$in_fh=$self->filehandle({locked=>1 },'<',$binmode);local $_;while (<$in_fh>){$cb->();$temp_fh->print($_)}close$temp_fh or $self->_throw('close',$temp);close$in_fh or $self->_throw('close');return$temp->move($resolved_path)}sub edit_lines_raw {$_[2]={binmode=>":unix" };goto&edit_lines}sub edit_lines_utf8 {$_[2]={binmode=>":raw:encoding(UTF-8)" };goto&edit_lines}sub exists {-e $_[0]->[PATH]}sub is_file {-e $_[0]->[PATH]&&!-d _}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked exclusive/);$args->{locked}=1 if$args->{exclusive};my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |= Fcntl::O_CREAT();$flags |= Fcntl::O_EXCL()if$args->{exclusive};sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){if (-w $self->[PATH]){$opentype="+<";$lock=Fcntl::LOCK_EX()}}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my ($counter,$mod,@result)=(0,abs($args->{count}));while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if$chomp;$result[$counter++ ]=$line;last if$counter==$args->{count};$counter %= $mod}splice(@result,0,0,splice(@result,$counter))if@result==$mod && $counter % $mod;return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})$//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}my$CRLF=qr/(?:\x{0d}?\x{0a}|\x{0d})/;sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU()))&& $args->{chomp}&&!$args->{count}){my$slurp=slurp_utf8($self);$slurp =~ s/$CRLF$//;return split$CRLF,$slurp,-1}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";return lines($self,$args)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.$)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/$}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;$self=$self->_resolve_symlinks;require Cwd;$self->_splitpath if!defined$self->[FILE];my$check_parent=length$self->[FILE]&& $self->[FILE]ne '.' && $self->[FILE]ne '..';my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($check_parent ? $self->parent->[PATH]: $self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath && length$realpath && -e $realpath;return ($check_parent ? path($realpath,$self->[FILE]): path($realpath))}sub relative {my ($self,$base)=@_;$base=path(defined$base && length$base ? $base : '.');$self=$self->absolute if$self->is_relative;$base=$base->absolute if$base->is_relative;$self=$self->absolute if!length$self->volume && length$base->volume;$base=$base->absolute if length$self->volume &&!length$base->volume;if (!_same($self->volume,$base->volume)){Carp::croak("relative() can't cross volumes: '$self' vs '$base'")}return path(".")if _same($self->[PATH],$base->[PATH]);if ($base->subsumes($self)){$base="" if$base->is_rootdir;my$relative="$self";$relative =~ s{\A\Q$base/}{};return path($relative)}my (@common,@self_parts,@base_parts);@base_parts=split /\//,$base->_just_filepath;if ($self->is_rootdir){@common=("");shift@base_parts}else {@self_parts=split /\//,$self->_just_filepath;while (@self_parts && @base_parts && _same($self_parts[0],$base_parts[0])){push@common,shift@base_parts;shift@self_parts}}if (my$new_base=$self->_resolve_between(\@common,\@base_parts)){return$self->relative($new_base)}my@new_path=(("..")x (0+ @base_parts),@self_parts);return path(@new_path)}sub _just_filepath {my$self=shift;my$self_vol=$self->volume;return "$self" if!length$self_vol;(my$self_path="$self")=~ s{\A\Q$self_vol}{};return$self_path}sub _resolve_between {my ($self,$common,$base)=@_;my$path=$self->volume .join("/",@$common);my$changed=0;for my$p (@$base){$path .= "/$p";if ($p eq '..'){$changed=1;if (-e $path){$path=path($path)->realpath->[PATH]}else {$path =~ s{/[^/]+/..$}{/}}}if (-l $path){$changed=1;$path=path($path)->realpath->[PATH]}}return$changed ? path($path): undef}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink($self->[PATH])|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub sibling {my$self=shift;return path($self->parent->[PATH],@_)}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$_[1]={binmode=>":unix:utf8_strict" };goto&slurp}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}map {ref eq 'ARRAY' ? @$_ : $_}@_)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){splice @_,1,0,{binmode=>":unix:utf8_strict" };goto&spew}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|$)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}if (defined$epoch){utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)")}else {utime undef,undef,$self->[PATH]or $self->_throw("utime ()")}return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub visit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);Carp::croak("Callback for visit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$next=$self->iterator($args);my$state={};while (my$file=$next->()){local $_=$file;my$r=$cb->($file,$state);last if ref($r)eq 'SCALAR' &&!$$r}return$state}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use strict;use warnings;our$VERSION='2.000006';$VERSION =~ tr/_//d;our%INFO;our%APPLIED_TO;our%COMPOSED;our%COMPOSITE_INFO;our@ON_ROLE_CREATE;BEGIN {*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0};*_WORK_AROUND_HINT_LEAKAGE ="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_MRO_MODULE="$]" < 5.010 ? sub(){"MRO/Compat.pm"}: sub(){"mro.pm"}}sub croak {require Carp;no warnings 'redefine';*croak=\&Carp::croak;goto&Carp::croak}sub Role::Tiny::__GUARD__::DESTROY {delete$INC{$_[0]->[0]}if @{$_[0]}}sub _load_module {my ($module)=@_;(my$file="$module.pm")=~ s{::}{/}g;return 1 if$INC{$file};return 1 if grep!/::\z/,keys %{_getstash($module)};my$guard=_WORK_AROUND_BROKEN_MODULE_STATE && bless([$file ],'Role::Tiny::__GUARD__');local %^H if _WORK_AROUND_HINT_LEAKAGE;require$file;pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;return 1}sub import {my$target=caller;my$me=shift;strict->import;warnings->import;$me->_install_subs($target);return if$me->is_role($target);$INFO{$target}{is_role}=1;my$stash=_getstash($target);my@not_methods=map +(ref $_ eq 'CODE' ? $_ : ref $_ ? (): *$_{CODE}||()),values %$stash;@{$INFO{$target}{not_methods}={}}{@not_methods}=@not_methods;$APPLIED_TO{$target}={$target=>undef };for my$hook (@ON_ROLE_CREATE){$hook->($target)}}sub _install_subs {my ($me,$target)=@_;return if$me->is_role($target);for my$type (qw(before after around)){*{_getglob "${target}::${type}"}=sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];return}}*{_getglob "${target}::requires"}=sub {push @{$INFO{$target}{requires}||=[]},@_;return};*{_getglob "${target}::with"}=sub {$me->apply_roles_to_package($target,@_);return}}sub role_application_steps {qw(_install_methods _check_requires _install_modifiers _copy_applied_list)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);croak "This is apply_role_to_package" if ref($to);croak "${role} is not a Role::Tiny" unless$me->is_role($role);for my$step ($me->role_application_steps){$me->$step($to,$role)}}sub _copy_applied_list {my ($me,$to,$role)=@_;@{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}}=()}sub apply_roles_to_object {my ($me,$object,@roles)=@_;croak "No roles supplied!" unless@roles;my$class=ref($object);bless($_[1],$me->create_class_with_roles($class,@roles))}my$role_suffix='A000';sub _composite_name {my ($me,$superclass,@roles)=@_;my$new_name=join('__WITH__',$superclass,my$compose_name=join '__AND__',@roles);if (length($new_name)> 252){$new_name=$COMPOSED{abbrev}{$new_name}||= do {my$abbrev=substr$new_name,0,250 - length$role_suffix;$abbrev =~ s/(?<!:):$//;$abbrev.'__'.$role_suffix++}}return wantarray ? ($new_name,$compose_name): $new_name}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;croak "No roles supplied!" unless@roles;_load_module($superclass);{my%seen;if (my@dupes=grep 1==$seen{$_}++,@roles){croak "Duplicated roles: ".join(', ',@dupes)}}my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);croak "${role} is not a Role::Tiny" unless$me->is_role($role)}require(_MRO_MODULE);my$composite_info=$me->_composite_info_for(@roles);my%conflicts=%{$composite_info->{conflicts}};if (keys%conflicts){my$fail=join "\n",map {"Method name conflict for '$_' between roles " ."'".join("' and '",sort values %{$conflicts{$_}})."'" .", cannot apply these simultaneously to an object."}keys%conflicts;croak$fail}my@composable=map$me->_composable_package_for($_),reverse@roles;my@requires=grep {my$method=$_;!grep $_->can($method)&&!$COMPOSED{role}{$_}{modifiers_only}{$method},@composable}@{$composite_info->{requires}};$me->_check_requires($superclass,$compose_name,\@requires);*{_getglob("${new_name}::ISA")}=[@composable,$superclass ];@{$APPLIED_TO{$new_name}||={}}{map keys %{$APPLIED_TO{$_}},@roles }=();$COMPOSED{class}{$new_name}=1;return$new_name}sub apply_role_to_package {shift->apply_single_role_to_package(@_)}sub apply_roles_to_package {my ($me,$to,@roles)=@_;return$me->apply_role_to_package($to,$roles[0])if@roles==1;my%conflicts=%{$me->_composite_info_for(@roles)->{conflicts}};my@have=grep$to->can($_),keys%conflicts;delete@conflicts{@have};if (keys%conflicts){my$fail=join "\n",map {"Due to a method name conflict between roles " ."'".join(' and ',sort values %{$conflicts{$_}})."'" .", the method '$_' must be implemented by '${to}'"}keys%conflicts;croak$fail}my@role_methods=map$me->_concrete_methods_of($_),@roles;local @{$_}{@have}for@role_methods;delete @{$_}{@have}for@role_methods;if ($INFO{$to}){delete$INFO{$to}{methods}}our%BACKCOMPAT_HACK;if($me ne __PACKAGE__ and exists$BACKCOMPAT_HACK{$me}? $BACKCOMPAT_HACK{$me}: $BACKCOMPAT_HACK{$me}=$me->can('role_application_steps')==\&role_application_steps && $me->can('apply_single_role_to_package')!=\&apply_single_role_to_package){for my$role (@roles){$me->apply_single_role_to_package($to,$role)}}else {for my$step ($me->role_application_steps){for my$role (@roles){$me->$step($to,$role)}}}$APPLIED_TO{$to}{join('|',@roles)}=1}sub _composite_info_for {my ($me,@roles)=@_;$COMPOSITE_INFO{join('|',sort@roles)}||= do {for my$role (@roles){_load_module($role)}my%methods;for my$role (@roles){my$this_methods=$me->_concrete_methods_of($role);$methods{$_}{$this_methods->{$_}}=$role for keys %$this_methods}my%requires;@requires{map @{$INFO{$_}{requires}||[]},@roles}=();delete$requires{$_}for keys%methods;delete$methods{$_}for grep keys(%{$methods{$_}})==1,keys%methods;+{conflicts=>\%methods,requires=>[keys%requires]}}}sub _composable_package_for {my ($me,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$me->_install_methods($composed_name,$role);my$base_name=$composed_name.'::_BASE';_getstash($base_name);{no strict 'refs';@{"${composed_name}::ISA"}=($base_name)}my$modifiers=$INFO{$role}{modifiers}||[];my@mod_base;my@modifiers=grep!$composed_name->can($_),do {my%h;@h{map @{$_}[1..$#$_-1],@$modifiers}=();keys%h};for my$modified (@modifiers){push@mod_base,"sub ${modified} { shift->next::method(\@_) }"}my$e;{local $@;eval(my$code=join "\n","package ${base_name};",@mod_base);$e="Evaling failed: $@\nTrying to eval:\n${code}" if $@}die$e if$e;$me->_install_modifiers($composed_name,$role);$COMPOSED{role}{$composed_name}={modifiers_only=>{map {$_=>1}@modifiers },};return$composed_name}sub _check_requires {my ($me,$to,$name,$requires)=@_;return unless my@requires=@{$requires||$INFO{$name}{requires}||[]};if (my@requires_fail=grep!$to->can($_),@requires){if (my$to_info=$INFO{$to}){push @{$to_info->{requires}||=[]},@requires_fail}else {croak "Can't apply ${name} to ${to} - missing ".join(', ',@requires_fail)}}}sub _concrete_methods_of {my ($me,$role)=@_;my$info=$INFO{$role};my$stash=_getstash($role);my$not_methods={reverse %{$info->{not_methods}||{}}};$info->{methods}||= +{map {;no strict 'refs';my$code=exists &{"${role}::$_"}? \&{"${role}::$_"}: undef;(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep +(!ref($stash->{$_})|| ref($stash->{$_})eq 'CODE'),keys %$stash }}sub methods_provided_by {my ($me,$role)=@_;croak "${role} is not a Role::Tiny" unless$me->is_role($role);(keys %{$me->_concrete_methods_of($role)},@{$INFO{$role}->{requires}||[]})}sub _install_methods {my ($me,$to,$role)=@_;my$info=$INFO{$role};my$methods=$me->_concrete_methods_of($role);my$stash=_getstash($to);my%has_methods;@has_methods{grep +(ref($stash->{$_})|| *{$stash->{$_}}{CODE}),keys %$stash }=();for my$i (grep!exists$has_methods{$_},keys %$methods){no warnings 'once';my$glob=_getglob "${to}::${i}";*$glob=$methods->{$i};next unless$i =~ /^\(/ && ((defined&overload::nil && $methods->{$i}==\&overload::nil)|| (defined&overload::_nil && $methods->{$i}==\&overload::_nil));my$overload=${*{_getglob "${role}::${i}"}{SCALAR}};next unless defined$overload;*$glob=\$overload}$me->_install_does($to)}sub _install_modifiers {my ($me,$to,$name)=@_;return unless my$modifiers=$INFO{$name}{modifiers};my$info=$INFO{$to};my$existing=($info ? $info->{modifiers}: $COMPOSED{modifiers}{$to})||= [];my@modifiers=grep {my$modifier=$_;!grep $_==$modifier,@$existing}@{$modifiers||[]};push @$existing,@modifiers;if (!$info){for my$modifier (@modifiers){$me->_install_single_modifier($to,@$modifier)}}}my$vcheck_error;sub _install_single_modifier {my ($me,@args)=@_;defined($vcheck_error)or $vcheck_error=do {local $@;eval {require Class::Method::Modifiers;Class::Method::Modifiers->VERSION(1.05);1}? 0 : $@};$vcheck_error and die$vcheck_error;Class::Method::Modifiers::install_modifier(@args)}my$FALLBACK=sub {0};sub _install_does {my ($me,$to)=@_;return if$me->is_role($to);my$does=$me->can('does_role');*{_getglob "${to}::does"}=$does unless$to->can('does');return if$to->can('DOES')and $to->can('DOES')!=(UNIVERSAL->can('DOES')|| 0);my$existing=$to->can('DOES')|| $to->can('isa')|| $FALLBACK;my$new_sub=sub {my ($proto,$role)=@_;$proto->$does($role)or $proto->$existing($role)};no warnings 'redefine';return *{_getglob "${to}::DOES"}=$new_sub}sub does_role {my ($proto,$role)=@_;require(_MRO_MODULE);for my$class (@{mro::get_linear_isa(ref($proto)||$proto)}){return 1 if exists$APPLIED_TO{$class}{$role}}return 0}sub is_role {my ($me,$role)=@_;return!!($INFO{$role}&& ($INFO{$role}{is_role}|| $INFO{$role}{not_methods}))}1;
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;use strict;use warnings;our$VERSION='2.000006';$VERSION=eval$VERSION;use Role::Tiny ();use Exporter 'import';our@EXPORT=qw(with);sub with {my$target=caller;Role::Tiny->apply_roles_to_package($target,@_)}1;
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strict;use warnings;use Exporter qw(import);use Scalar::Util qw(weaken);use Carp qw(croak);our$VERSION='2.005000';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub undefer_all);our@EXPORT_OK=qw(undefer_package defer_info);our%DEFERRED;sub _getglob {no strict 'refs';\*{$_[0]}}BEGIN {my$no_subname;*_subname =defined&Sub::Util::set_subname ? \&Sub::Util::set_subname : defined&Sub::Name::subname ? \&Sub::Name::subname : (eval {require Sub::Util}&& defined&Sub::Util::set_subname)? \&Sub::Util::set_subname : (eval {require Sub::Name}&& defined&Sub::Name::subname)? \&Sub::Name::subname : ($no_subname=1,sub {$_[1]});*_CAN_SUBNAME=$no_subname ? sub(){0}: sub(){1}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub undefer_sub {my ($deferred)=@_;my$info=$DEFERRED{$deferred}or return$deferred;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){return$deferred}return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}my$undefer_info=[$target,$maker,$options,\$$undeferred_ref ];$info->[5]=$DEFERRED{$made}=$undefer_info;weaken ${$undefer_info->[3]};return$made}sub undefer_all {undefer_sub($_)for keys%DEFERRED;return}sub undefer_package {my$package=shift;undefer_sub($_)for grep {my$name=$DEFERRED{$_}&& $DEFERRED{$_}[0];$name && $name =~ /^${package}::[^:]+$/}keys%DEFERRED;return}sub defer_info {my ($deferred)=@_;my$info=$DEFERRED{$deferred||''}or return undef;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){delete$DEFERRED{$deferred};return undef}[$target,$maker,$options,($undeferred_ref && $$undeferred_ref ? $$undeferred_ref : ()),]}sub defer_sub {my ($target,$maker,$options)=@_;my$package;my$subname;($package,$subname)=$target =~ /^(.*)::([^:]+)$/ or croak "$target is not a fully qualified sub name!" if$target;$package ||= $options && $options->{package}|| caller;my@attributes=@{$options && $options->{attributes}|| []};if (@attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for@attributes}my$deferred;my$undeferred;my$deferred_info=[$target,$maker,$options,\$undeferred ];if (@attributes || $target &&!_CAN_SUBNAME){my$code =q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n] .qq[package $package;\n] .($target ? "sub $subname" : '+sub').join('',map " :$_",@attributes).q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[4]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n" .($target ? "\\&$subname" : '');my$e;$deferred=do {no warnings qw(redefine closure);local $@;eval$code or $e=$@};die$e if defined$e}else {$deferred=sub {$undeferred ||= undefer_sub($deferred_info->[4]);goto &$undeferred};_install_coderef($target,$deferred)if$target}weaken($deferred_info->[4]=$deferred);weaken($DEFERRED{$deferred}=$deferred_info);return$deferred}sub CLONE {%DEFERRED=map {defined $_ ? ($_->[4]? ($_->[4]=>$_): ($_->[3]&& ${$_->[3]})? (${$_->[3]}=>$_): ()): ()}values%DEFERRED}1;
SUB_DEFER

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;use strict;use warnings;package Sub::Exporter;{$Sub::Exporter::VERSION='0.987'}use Carp ();use Data::OptList 0.100 ();use Params::Util 0.14 ();use Sub::Install 0.92 ();sub _group_name {my ($name)=@_;return if (index q{-:},(substr$name,0,1))==-1;return substr$name,1}sub _expand_groups {my ($class,$config,$groups,$collection,$seen,$merge)=@_;$seen ||= {};$merge ||= {};my@groups=@$groups;for my$i (reverse 0 .. $#groups){if (my$group_name=_group_name($groups[$i][0])){my$seen={%$seen };splice@groups,$i,1,_expand_group($class,$config,$groups[$i],$collection,$seen,$merge)}else {next unless my%merge=%$merge;my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';if (Params::Util::_CODELIKE($groups[$i][1])or Params::Util::_SCALAR0($groups[$i][1])){$groups[$i][0]=$prefix .$groups[$i][0].$suffix}else {my$as =ref$groups[$i][1]{-as}? $groups[$i][1]{-as}: $groups[$i][1]{-as}? $prefix .$groups[$i][1]{-as}.$suffix : $prefix .$groups[$i][0].$suffix;$groups[$i][1]={%{$groups[$i][1]},%merge,-as=>$as }}}}return \@groups}sub _expand_group {my ($class,$config,$group,$collection,$seen,$merge)=@_;$merge ||= {};my ($group_name,$group_arg)=@$group;$group_name=_group_name($group_name);Carp::croak qq(group "$group_name" is not exported by the $class module) unless exists$config->{groups}{$group_name};return if$seen->{$group_name}++;if (ref$group_arg){my$prefix=(delete$merge->{-prefix}||'').($group_arg->{-prefix}||'');my$suffix=($group_arg->{-suffix}||'').(delete$merge->{-suffix}||'');$merge={%$merge,%$group_arg,($prefix ? (-prefix=>$prefix): ()),($suffix ? (-suffix=>$suffix): ()),}}my$exports=$config->{groups}{$group_name};if (Params::Util::_CODELIKE($exports)or Params::Util::_SCALAR0($exports)){my$group_arg=$merge ? {%$merge }: {};delete$group_arg->{-prefix};delete$group_arg->{-suffix};my$group=Params::Util::_CODELIKE($exports)? $exports->($class,$group_name,$group_arg,$collection): $class->$$exports($group_name,$group_arg,$collection);Carp::croak qq(group generator "$group_name" did not return a hashref) if ref$group ne 'HASH';my$stuff=[map {[$_=>$group->{$_}]}keys %$group ];return @{_expand_groups($class,$config,$stuff,$collection,$seen,$merge)}}else {$exports =Data::OptList::mkopt($exports,"$group_name exports");return @{_expand_groups($class,$config,$exports,$collection,$seen,$merge)}}}sub _mk_collection_builder {my ($col,$etc)=@_;my ($config,$import_args,$class,$into)=@$etc;my%seen;sub {my ($collection)=@_;my ($name,$value)=@$collection;Carp::croak "collection $name provided multiple times in import" if$seen{$name }++;if (ref(my$hook=$config->{collectors}{$name})){my$arg={name=>$name,config=>$config,import_args=>$import_args,class=>$class,into=>$into,};my$error_msg="collection $name failed validation";if (Params::Util::_SCALAR0($hook)){Carp::croak$error_msg unless$class->$$hook($value,$arg)}else {Carp::croak$error_msg unless$hook->($value,$arg)}}$col->{$name }=$value}}sub _collect_collections {my ($config,$import_args,$class,$into)=@_;my@collections =map {splice @$import_args,$_,1}grep {exists$config->{collectors}{$import_args->[$_][0]}}reverse 0 .. $#$import_args;unshift@collections,[INIT=>{}]if$config->{collectors}{INIT};my$col={};my$builder=_mk_collection_builder($col,\@_);for my$collection (@collections){$builder->($collection)}return$col}sub setup_exporter {my ($config)=@_;Carp::croak 'into and into_level may not both be supplied to exporter' if exists$config->{into}and exists$config->{into_level};my$as=delete$config->{as}|| 'import';my$into =exists$config->{into}? delete$config->{into}: exists$config->{into_level}? caller(delete$config->{into_level}): caller(0);my$import=build_exporter($config);Sub::Install::reinstall_sub({code=>$import,into=>$into,as=>$as,})}sub _key_intersection {my ($x,$y)=@_;my%seen=map {$_=>1}keys %$x;my@names=grep {$seen{$_}}keys %$y}my%valid_config_key;BEGIN {%valid_config_key=map {$_=>1}qw(as collectors installer generator exports groups into into_level),qw(exporter),}sub _assert_collector_names_ok {my ($collectors)=@_;for my$reserved_name (grep {/\A[_A-Z]+\z/}keys %$collectors){Carp::croak "unknown reserved collector name: $reserved_name" if$reserved_name ne 'INIT'}}sub _rewrite_build_config {my ($config)=@_;if (my@keys=grep {not exists$valid_config_key{$_}}keys %$config){Carp::croak "unknown options (@keys) passed to Sub::Exporter"}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};if ($config->{exporter}){Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";$config->{installer}=delete$config->{exporter}}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};for (qw(exports collectors)){$config->{$_}=Data::OptList::mkopt_hash($config->{$_},$_,['CODE','SCALAR' ],)}_assert_collector_names_ok($config->{collectors});if (my@names=_key_intersection(@$config{qw(exports collectors)})){Carp::croak "names (@names) used in both collections and exports"}$config->{groups}=Data::OptList::mkopt_hash($config->{groups},'groups',['HASH','ARRAY','CODE','SCALAR',]);$config->{groups}{default}||= [];$config->{groups}{all}||= [keys %{$config->{exports}}];$config->{generator}||= \&default_generator;$config->{installer}||= \&default_installer}sub build_exporter {my ($config)=@_;_rewrite_build_config($config);my$import=sub {my ($class)=shift;my$special=(ref $_[0])? shift(@_): {};Carp::croak q(into and into_level may not both be supplied to exporter) if exists$special->{into}and exists$special->{into_level};if ($special->{exporter}){Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";$special->{installer}=delete$special->{exporter}}my$into =defined$special->{into}? delete$special->{into}: defined$special->{into_level}? caller(delete$special->{into_level}): defined$config->{into}? $config->{into}: defined$config->{into_level}? caller($config->{into_level}): caller(0);my$generator=delete$special->{generator}|| $config->{generator};my$installer=delete$special->{installer}|| $config->{installer};my$import_args=Data::OptList::mkopt([@_ ]);$import_args=[[-default=>undef ]]unless @$import_args;my$collection=_collect_collections($config,$import_args,$class,$into);my$to_import=_expand_groups($class,$config,$import_args,$collection);_do_import({class=>$class,col=>$collection,config=>$config,into=>$into,generator=>$generator,installer=>$installer,},$to_import,)};return$import}sub _do_import {my ($arg,$to_import)=@_;my@todo;for my$pair (@$to_import){my ($name,$import_arg)=@$pair;my ($generator,$as);if ($import_arg and Params::Util::_CODELIKE($import_arg)){$generator=sub {$import_arg};$as=$name}else {$import_arg={$import_arg ? %$import_arg : ()};Carp::croak qq("$name" is not exported by the $arg->{class} module) unless exists$arg->{config}{exports}{$name};$generator=$arg->{config}{exports}{$name};$as=exists$import_arg->{-as}? (delete$import_arg->{-as}): $name}my$code=$arg->{generator}->({class=>$arg->{class},name=>$name,arg=>$import_arg,col=>$arg->{col},generator=>$generator,});push@todo,$as,$code}$arg->{installer}->({class=>$arg->{class},into=>$arg->{into},col=>$arg->{col},},\@todo,)}sub default_generator {my ($arg)=@_;my ($class,$name,$generator)=@$arg{qw(class name generator)};if (not defined$generator){my$code=$class->can($name)or Carp::croak "can't locate exported subroutine $name via $class";return$code}return$generator->($class,$name,$arg->{arg},$arg->{col})if Params::Util::_CODELIKE($generator);return$class->$$generator($name,$arg->{arg},$arg->{col})}sub default_installer {my ($arg,$to_export)=@_;for (my$i=0;$i < @$to_export;$i += 2){my ($as,$code)=@$to_export[$i,$i+1 ];if (ref$as eq 'SCALAR'){$$as=$code}elsif (ref$as){Carp::croak "invalid reference type for $as: " .ref$as}else {Sub::Install::reinstall_sub({code=>$code,into=>$arg->{into},as=>$as })}}}sub default_exporter {Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";goto&default_installer}setup_exporter({exports=>[qw(setup_exporter build_exporter),_import=>sub {build_exporter($_[2])},],groups=>{all=>[qw(setup_exporter build_export) ],},collectors=>{-setup=>\&_setup },});sub _setup {my ($value,$arg)=@_;if (ref$value eq 'HASH'){push @{$arg->{import_args}},[_import=>{-as=>'import',%$value }];return 1}elsif (ref$value eq 'ARRAY'){push @{$arg->{import_args}},[_import=>{-as=>'import',exports=>$value }];return 1}return}"jn8:32";
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;$Sub::Exporter::Progressive::VERSION='0.001013';use strict;use warnings;sub _croak {require Carp;&Carp::croak}sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';no warnings 'once';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (grep {length ref $_ or $_ !~ / \A [:-]? \w+ \z /xm}@args){_croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined((my ($num)=grep {m/^\d/}@args)[0])){_croak "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if (($setup||'')eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){_croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};_croak$too_complicated if grep {length ref $_}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){_croak$too_complicated if grep {length ref $_ or $_ =~ / \A - (?! all \b ) /x}@{$tagset}}@defaults=@{$tags{default}|| []}}else {_croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||= [@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;_croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;use warnings;package Sub::Exporter::Util;{$Sub::Exporter::Util::VERSION='0.987'}use Data::OptList ();use Params::Util ();sub curry_method {my$override_name=shift;sub {my ($class,$name)=@_;$name=$override_name if defined$override_name;sub {$class->$name(@_)}}}BEGIN {*curry_class=\&curry_method}sub curry_chain {my (@opt_list)=@_;my$pairs=Data::OptList::mkopt(\@opt_list,'args','ARRAY');sub {my ($class)=@_;sub {my$next=$class;for my$i (0 .. $#$pairs){my$pair=$pairs->[$i ];unless (Params::Util::_INVOCANT($next)){my$str=defined$next ? "'$next'" : 'undef';Carp::croak("can't call $pair->[0] on non-invocant $str")}my ($method,$args)=@$pair;if ($i==$#$pairs){return$next->$method($args ? @$args : ())}else {$next=$next->$method($args ? @$args : ())}}}}}sub merge_col {my (%groups)=@_;my%merged;while (my ($default_name,$group)=each%groups){while (my ($export_name,$gen)=each %$group){$merged{$export_name}=sub {my ($class,$name,$arg,$col)=@_;my$merged_arg=exists$col->{$default_name}? {%{$col->{$default_name}},%$arg }: $arg;if (Params::Util::_CODELIKE($gen)){$gen->($class,$name,$merged_arg,$col)}else {$class->$$gen($name,$merged_arg,$col)}}}}return%merged}sub __mixin_class_for {my ($class,$mix_into)=@_;require Package::Generator;my$mixin_class=Package::Generator->new_package({base=>"$class\:\:__mixin__",});no strict 'refs';if (ref$mix_into){unshift @{"$mixin_class" ."::ISA"},ref$mix_into}else {unshift @{"$mix_into" ."::ISA"},$mixin_class}return$mixin_class}sub mixin_installer {sub {my ($arg,$to_export)=@_;my$mixin_class=__mixin_class_for($arg->{class},$arg->{into});bless$arg->{into}=>$mixin_class if ref$arg->{into};Sub::Exporter::default_installer({%$arg,into=>$mixin_class},$to_export,)}}sub mixin_exporter {Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";return mixin_installer}sub like {sub {my ($value,$arg)=@_;Carp::croak "no regex supplied to regex group generator" unless$value;my@values=eval {$value->isa('Regexp')}? ($value,undef): @$value;while (my ($re,$opt)=splice@values,0,2){Carp::croak "given pattern for regex group generater is not a Regexp" unless eval {$re->isa('Regexp')};my@exports=keys %{$arg->{config}->{exports}};my@matching=grep {$_ =~ $re}@exports;my%merge=$opt ? %$opt : ();my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';for my$name (@matching){my$as=$prefix .$name .$suffix;push @{$arg->{import_args}},[$name=>{%merge,-as=>$as }]}}1}}use Sub::Exporter -setup=>{exports=>[qw(like name_map merge_col curry_method curry_class curry_chain mixin_installer mixin_exporter) ]};1;
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;use warnings;package Sub::Install;$Sub::Install::VERSION='0.928';use Carp;use Scalar::Util ();sub _name_of_code {my ($code)=@_;require B;my$name=B::svref_2object($code)->GV->NAME;return$name unless$name =~ /\A__ANON__/;return}sub _CODELIKE {(Scalar::Util::reftype($_[0])||'')eq 'CODE' || Scalar::Util::blessed($_[0])&& (overload::Method($_[0],'&{}')? $_[0]: undef)}sub _build_public_installer {my ($installer)=@_;sub {my ($arg)=@_;my ($calling_pkg)=caller(0);for (qw(into from)){$arg->{$_}=$calling_pkg unless$arg->{$_}}Carp::croak "named argument 'code' is not optional" unless$arg->{code};if (_CODELIKE($arg->{code})){$arg->{as}||= _name_of_code($arg->{code})}else {Carp::croak "couldn't find subroutine named $arg->{code} in package $arg->{from}" unless my$code=$arg->{from}->can($arg->{code});$arg->{as}=$arg->{code}unless$arg->{as};$arg->{code}=$code}Carp::croak "couldn't determine name under which to install subroutine" unless$arg->{as};$installer->(@$arg{qw(into as code) })}}my$_misc_warn_re;my$_redef_warn_re;BEGIN {$_misc_warn_re=qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;$_redef_warn_re=qr/Subroutine\ .+?\ redefined/x}my$eow_re;BEGIN {$eow_re=qr/ at .+? line \d+\.\Z/};sub _do_with_warn {my ($arg)=@_;my$code=delete$arg->{code};my$wants_code=sub {my$code=shift;sub {my$warn=$SIG{__WARN__}? $SIG{__WARN__}: sub {warn @_};local$SIG{__WARN__}=sub {my ($error)=@_;for (@{$arg->{suppress}}){return if$error =~ $_}for (@{$arg->{croak}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){Carp::croak$base_error}}for (@{$arg->{carp}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){return$warn->(Carp::shortmess$base_error)}}($arg->{default}|| $warn)->($error)};$code->(@_)}};return$wants_code->($code)if$code;return$wants_code}sub _installer {sub {my ($pkg,$name,$code)=@_;no strict 'refs';*{"$pkg\::$name"}=$code;return$code}}BEGIN {*_ignore_warnings=_do_with_warn({carp=>[$_misc_warn_re,$_redef_warn_re ]});*install_sub=_build_public_installer(_ignore_warnings(_installer));*_carp_warnings=_do_with_warn({carp=>[$_misc_warn_re ],suppress=>[$_redef_warn_re ],});*reinstall_sub=_build_public_installer(_carp_warnings(_installer));*_install_fatal=_do_with_warn({code=>_installer,croak=>[$_redef_warn_re ],})}sub install_installers {my ($into)=@_;for my$method (qw(install_sub reinstall_sub)){my$code=sub {my ($package,$subs)=@_;my ($caller)=caller(0);my$return;for (my ($name,$sub)=%$subs){$return=Sub::Install->can($method)->({code=>$sub,from=>$caller,into=>$package,as=>$name })}return$return};install_sub({code=>$code,into=>$into,as=>$method })}}sub exporter {my ($arg)=@_;my%is_exported=map {$_=>undef}@{$arg->{exports}};sub {my$class=shift;my$target=caller;for (@_){Carp::croak "'$_' is not exported by $class" if!exists$is_exported{$_};install_sub({code=>$_,from=>$class,into=>$target })}}}BEGIN {*import=exporter({exports=>[qw(install_sub reinstall_sub) ]})}1;
SUB_INSTALL

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;sub _clean_eval {eval $_[0]}use strict;use warnings;use Sub::Defer qw(defer_sub);use Scalar::Util qw(weaken);use Exporter qw(import);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Sub::Defer)}use B ();BEGIN {*_HAVE_IS_UTF8=defined&utf8::is_utf8 ? sub(){1}: sub(){0};*_HAVE_PERLSTRING=defined&B::perlstring ? sub(){1}: sub(){0}}our$VERSION='2.005000';$VERSION=eval$VERSION;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub qsub);our@EXPORT_OK=qw(quotify capture_unroll inlinify sanitize_identifier);our%QUOTED;sub quotify {my$value=$_[0];no warnings 'numeric';!defined$value ? 'undef()' : (!(_HAVE_IS_UTF8 && utf8::is_utf8($value))&& length((my$dummy='')& $value)&& 0 + $value eq $value && $value * 0==0)? $value : _HAVE_PERLSTRING ? B::perlstring($value): qq["\Q$value\E"]}sub sanitize_identifier {my$name=shift;$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;$name}sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or croak "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;my$do='do { '.($extra||'');if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//){$do .= $1}if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms){my ($pre,$indent,$code_args)=($1,$2,$3);$do .= $pre;if ($code_args ne $args){$do .= $indent .'my ('.$code_args.') = ('.$args.'); '}}elsif ($local || $args ne '@_'){$do .= ($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$code.' }'}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=ref($_[-1])eq 'HASH' ? pop : undef;undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];if ($name){my$subname=$name;my$package=$subname =~ s/(.*)::// ? $1 : caller;$name=join '::',$package,$subname;croak qq{package name "$package" too long!} if length$package > 252;croak qq{package name "$package" is not valid!} unless$package =~ /^[^\d\W]\w*(?:::\w+)*$/;croak qq{sub name "$subname" too long!} if length$subname > 252;croak qq{sub name "$subname" is not valid!} unless$subname =~ /^[^\d\W]\w*$/}my@caller=caller(0);my ($attributes,$file,$line)=@{$options}{qw(attributes file line)};if ($attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for @$attributes}my$quoted_info={name=>$name,code=>$code,captures=>$captures,package=>(exists$options->{package}? $options->{package}: $caller[0]),hints=>(exists$options->{hints}? $options->{hints}: $caller[8]),warning_bits=>(exists$options->{warning_bits}? $options->{warning_bits}: $caller[9]),hintshash=>(exists$options->{hintshash}? $options->{hintshash}: $caller[10]),($attributes ? (attributes=>$attributes): ()),($file ? (file=>$file): ()),($line ? (line=>$line): ()),};my$unquoted;weaken($quoted_info->{unquoted}=\$unquoted);if ($options->{no_defer}){my$fake=\my$var;local$QUOTED{$fake}=$quoted_info;my$sub=unquote_sub($fake);Sub::Defer::_install_coderef($name,$sub)if$name &&!$options->{no_install};return$sub}else {my$deferred=defer_sub(($options->{no_install}? undef : $name),sub {$unquoted if 0;unquote_sub($quoted_info->{deferred})},{($attributes ? (attributes=>$attributes): ()),($name ? (): (package=>$quoted_info->{package})),},);weaken($quoted_info->{deferred}=$deferred);weaken($QUOTED{$deferred}=$quoted_info);return$deferred}}sub _context {my$info=shift;$info->{context}||= do {my ($package,$hints,$warning_bits,$hintshash,$file,$line)=@{$info}{qw(package hints warning_bits hintshash file line)};$line ||= 1 if$file;my$line_mark='';if ($line){$line_mark="#line ".($line-1);if ($file){$line_mark .= qq{ "$file"}}$line_mark .= "\n"}$info->{context}="# BEGIN quote_sub PRELUDE\n" ."package $package;\n" ."BEGIN {\n" ."  \$^H = ".quotify($hints).";\n" ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n" ."  \%^H = (\n" .join('',map "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",keys %$hintshash)."  );\n" ."}\n" .$line_mark ."# END quote_sub PRELUDE\n"}}sub quoted_from_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub||''}or return undef;my ($name,$code,$captures,$unquoted,$deferred)=@{$quoted_info}{qw(name code captures unquoted deferred)};$code=_context($quoted_info).$code;$unquoted &&= $$unquoted;if (($deferred && $deferred eq $sub)|| ($unquoted && $unquoted eq $sub)){return [$name,$code,$captures,$unquoted,$deferred ]}return undef}sub unquote_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub}or return undef;my$unquoted=$quoted_info->{unquoted};unless ($unquoted && $$unquoted){my ($name,$code,$captures,$package,$attributes)=@{$quoted_info}{qw(name code captures package attributes)};($package,$name)=$name =~ /(.*)::(.*)/ if$name;my%captures=$captures ? %$captures : ();$captures{'$_UNQUOTED'}=\$unquoted;$captures{'$_QUOTED'}=\$quoted_info;my$make_sub ="{\n" .capture_unroll("\$_[1]",\%captures,2)."  package ${package};\n" .($name ? "  no warnings 'closure';\n  sub ${name} " : "  \$\$_UNQUOTED = sub ").($attributes ? join('',map ":$_ ",@$attributes): '')."{\n" ."  (\$_QUOTED,\$_UNQUOTED) if 0;\n" ._context($quoted_info).$code ."  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '').";\n" ."}\n" ."1;\n";$ENV{SUB_QUOTE_DEBUG}&& warn$make_sub;{no strict 'refs';local *{"${package}::${name}"}if$name;my ($success,$e);{local $@;$success=_clean_eval($make_sub,\%captures);$e=$@}unless ($success){my$space=length($make_sub =~ tr/\n//);my$line=0;$make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e"}weaken($QUOTED{$$unquoted}=$quoted_info)}}$$unquoted}sub qsub ($) {goto&quote_sub}sub CLONE {my@quoted=map {defined $_ ? ($_->{unquoted}&& ${$_->{unquoted}}? (${$_->{unquoted}}=>$_): (),$_->{deferred}? ($_->{deferred}=>$_): (),): ()}values%QUOTED;%QUOTED=@quoted;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"Time/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_PROGRESS';
  package Time::Progress;use 5.006;use strict;use warnings;use Carp;our$VERSION='2.12';our$SMOOTHING_DELTA_DEFAULT='0.1';our%ATTRS=(min=>1,max=>1,format=>1,smoothing=>1,smoothing_delta=>1,);sub new {my$class=shift;my$self={min=>0,max=>100,smoothing=>0,smoothing_delta=>$SMOOTHING_DELTA_DEFAULT };bless$self;$self->attr(@_);$self->restart();return$self}sub attr {my$self=shift;croak "bad number of attribute/value pairs" unless @_==0 or @_ % 2==0;my@ret;my%h=@_;for(keys%h){croak "invalid attribute name: $_" unless$ATTRS{$_ };$self->{$_ }=$h{$_ }if defined$h{$_ };push@ret,$self->{$_ }}return@ret}sub restart {my$self=shift;my@ret=$self->attr(@_);$self->{'start' }=time();$self->{'stop' }=undef;return@ret}sub stop {my$self=shift;$self->{'stop' }=time()}sub continue {my$self=shift;$self->{'stop' }=undef}sub report {my$self=shift;my$format=shift || $self->{'format' };my$cur=shift;my$start=$self->{'start' };my$now=$self->{'stop' }|| time();croak "use restart() first" unless$start > 0;croak "time glitch (running backwards?)" if$now < $start;croak "empty format, use format() first" unless$format;my$l=$now - $start;my$L=sprintf "%3d:%02d",int($l / 60),($l % 60);my$min=$self->{'min' };my$max=$self->{'max' };my$last_e=$self->{'last_e' };my$sdelta=$self->{'smoothing_delta' };$cur=$min unless defined$cur;$sdelta=$SMOOTHING_DELTA_DEFAULT unless$sdelta > 0 and $sdelta < 1;my$b='n/a';my$bl=79;if ($format =~ /%(\d*)[bB]/){$bl=$1;$bl=79 if$bl eq '' or $bl < 1}my$e="n/a";my$E="n/a";my$f="n/a";my$p="n/a";if ((($min <= $cur and $cur <= $max)or ($min >= $cur and $cur >= $max))){if ($cur - $min==0){$e=0}else {$e=$l * ($max - $min)/ ($cur - $min);$e=int($e - $l);if ($self->{'smoothing' }&& $last_e && $last_e < $e && (($e - $last_e)/ $last_e)< $sdelta){$e=$last_e}$e=0 if$e < 0;$self->{last_e}=$e if$self->{'smoothing' }}$E=sprintf "%3d:%02d",int($e / 60),($e % 60);$f=$now + $e;$f=localtime($f);if ($max - $min!=0){$p=100 * ($cur - $min)/ ($max - $min);$b='#' x int($bl * $p / 100).'.' x $bl;$b=substr$b,0,$bl;$p=sprintf "%5.1f%%",$p}}$format =~ s/%(\d*)l/$self->sp_format( $l, $1 )/ge;$format =~ s/%(\d*)L/$self->sp_format( $L, $1 )/ge;$format =~ s/%(\d*)e/$self->sp_format( $e, $1 )/ge;$format =~ s/%(\d*)E/$self->sp_format( $E, $1 )/ge;$format =~ s/%p/$p/g;$format =~ s/%f/$f/g;$format =~ s/%\d*[bB]/$b/g;return$format}sub sp_format {my$self=shift;my$val=shift;my$len=shift;return$val unless$len ne '' and $len > 0;return sprintf("%${len}s",$val)}sub elapsed {my$self=shift;return$self->report("%l",@_)}sub elapsed_str {my$self=shift;return$self->report("elapsed time is %L min.\n",@_)}sub estimate {my$self=shift;return$self->report("%e",@_)}sub estimate_str {my$self=shift;return$self->report("remaining time is %E min.\n",@_)}1;
TIME_PROGRESS

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.30';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use Moo::_strictures;use Moo::_Utils qw(_load_module);sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

package SWR;

use strict;
use warnings;

use Moo;
use CLI::Osprey
  desc => "SWR meter";

use Time::Progress;

my @BANDS = (
  { name => '160m', start => 1800000,  end => 2000000,  tags => ['mf'] },
  { name => '80m',  start => 3500000,  end => 4000000,  tags => ['hf'] },
  { name => '60m',  start => 5300000,  end => 5500000,  tags => ['hf'] },
  { name => '40m',  start => 7000000,  end => 7300000,  tags => ['hf'] },
  { name => '30m',  start => 10100000, end => 10150000, tags => ['hf', 'warc'] },
  { name => '20m',  start => 14000000, end => 14350000, tags => ['hf'] },
  { name => '17m',  start => 18068000, end => 18168000, tags => ['hf', 'warc'] },
  { name => '15m',  start => 21000000, end => 21450000, tags => ['hf'] },
  { name => '12m',  start => 24890000, end => 24990000, tags => ['hf', 'warc'] },
  { name => '10m',  start => 28000000, end => 29700000, tags => ['hf'] },
  { name => '6m',   start => 50000000, end => 54000000, tags => ['vhf'] },
);

option 'start' => (
  is => 'ro',
  format => 'f',
  doc => 'Starting frequency',
  forrmat_doc => 'kHz',
  default => 1700,
);

has 'start_hz' => (
  is => 'lazy',
  default => sub { int(shift->start * 1000 + 0.5) }
);

option 'end' => (
  is => 'ro',
  format => 'f',
  doc => 'Ending frequency',
  format_doc => 'kHz',
  default => 54000,
);

has 'end_hz' => (
  is => 'lazy',
  default => sub { int(shift->end * 1000 + 0.5) }
);

option 'step' => (
  is => 'ro',
  format => 'f',
  doc => 'Frequency step',
  format_doc => 'kHz',
  spacer_below => 1,
  default => 10,
);

has 'step_hz' => (
  is => 'lazy',
  default => sub { int(shift->step * 1000 + 0.5) }
);

option 'bands' => (
  is => 'ro',
  doc => 'Highlight amateur bands',
  default => 1,
  negatable => 1,
);

option 'warc' => (
  is => 'ro',
  doc => 'Include WARC bands',
  default => 1,
  negatable => 1,
  spacer_below => 1,
);

option 'width' => (
  is => 'ro',
  doc => 'Graph width',
  format => 'i',
  default => 1280,
);

option 'height' => (
  is => 'ro',
  doc => 'Graph height',
  format => 'i',
  default => 720,
);

option 'font' => (
  is => 'ro',
  doc =>  'Font',
  format => 's',
  default => 'sans,16',
);

option 'threshold' => (
  is => 'ro',
  doc => 'Plot horizontal lines',
  format => 'f',
  format_doc => 'SWR',
  repeatable =>  1,
  spacer_below => 1,
  default => sub { [2, 3] },
);

option 'maxswr' => (
  is => 'ro',
  doc => 'Maximum SWR for top of graph',
  format => 'f',
  format_doc =>'SWR',
);

option 'smooth' => (
  is => 'ro',
  doc => 'Smoothing',
  format => 's',
  spacer_below => 1,
);

option 'portname' => (
  is => 'ro',
  doc => 'Serial port to use',
  option => 'port',
  short => 'p',
  format => 's',
  default => '/dev/ttyUSB1',
);

has 'port' => (
  is => 'lazy',
);

option 'name' => (
  is => 'ro',
  doc => 'Output filename base',
  format => 's',
  default => 'swr',
);

sub _build_port {
  my ($self) = @_;

  open my $fh, '+<', $self->portname or die "$! opening " . $self->portname . "\n";
  my $pid = fork;
  die "$! forking child for stty\n" unless defined $pid;
  if (!$pid) { # child
    open(STDIN, '<&', $fh) or die "$! dup'ing stdin\n";
    open(STDOUT, '>&', $fh) or die "$! dup'ing stdout\n";
    exec('stty', '57600', 'cs8', '-cstopb', '-parenb', '-echo'); # 57600 8N1 no local echo
  }
  wait;
  die "stty returned status $?\n" if $? > 0;
  return $fh;
}

sub acquire_data {
  my ($self) = @_;

  my $port = $self->port;
  open my $out, '>', $self->name . '.txt' or die "$! opening " . $self->name . '.txt';

  printf $port "scan %d %d %d\r\n", $self->start_hz, $self->end_hz + $self->step_hz, $self->step_hz;
  my $freq = $self->start_hz;
  my $started;
  my $progress = Time::Progress->new(min => $self->start_hz, max => $self->end_hz);

  while (my $line = <$port>) {
    $line =~ s/\r?\n\z//;
    last if $line eq 'End';
    if ($line eq 'Start') {
      $started = 1;
      $progress->restart;
      next;
    }
    next unless $started;
    my ($swr, $r, $x, $z) = split ",", $line;
    print $out "$freq\t$swr\t$r\t$x\t$z\n";
    print STDERR $progress->report("\rAcquiring data [%40b] %p ETA %E    \b\b\b\b", $freq);
    $freq += $self->step_hz;
  }
  print STDERR "\n";
}

sub gen_swrplot {
  my ($self) = @_;

  open my $out, '>', $self->name . '.gnuplot' or die "$! opening ". $self->name . ".gnuplot\n";
  print $out qq{set format x "%.2s%cHz"\n};
  print $out qq{set format y "%.2f"\n};

  if ($self->bands) {
    print $out qq{set style rect fc lt -1 fs solid 0.15 noborder\n};
    for my $band (@BANDS) {
      my %tags;
      $tags{$_} = 1 for $band->{tags};
      next if $tags{warc} && !$self->warc;

      print $out qq{set obj rect from $band->{start}, graph 0 to $band->{end}, graph 1\n};
    }
  }

  print $out "set terminal pngcairo enhanced size ", $self->width, ",", $self->height, qq{ font "}, $self->font, qq{"\n};
  print $out qq{set output "} . $self->name . qq{.png"\n};

  print $out <<EOF;
set size .975, 1
set style line 11 lc rgb '#404040' lt 1
set border 3 back ls 11
set tics nomirror
set style line 12 lc rgb '#404040' lt 0
set grid back ls 12
EOF

  if (my $threshold = $self->threshold) {
    print $out qq{set style line 13 lt 2 dt 2 lc rgb "#404040"\n};

    for my $swr (@$threshold) {
      print $out qq{set arrow from graph 0, first $swr to graph 1, first $swr ls 13 nohead\n};
    }
  }

  print $out qq{plot [}, $self->start_hz, qq{:] [1:};
  if ($self->maxswr) {
    print $out $self->maxswr;
  }
  print $out qq{] "} . $self->name . qq{.txt" using 1:2 with lines ti "SWR"};
  if ($self->smooth) {
    print $out " smooth ", $self->smooth;
  }
  print $out "\n";
  system("gnuplot", $self->name . ".gnuplot");
}

sub run {
  my ($self) = @_;
  $self->acquire_data;
  $self->gen_swrplot;
}

package main;
SWR->new_with_options->run;
